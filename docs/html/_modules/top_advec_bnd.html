<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>top_advec_bnd &mdash; Topological Advection 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=8d563738"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Topological Advection
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Topological Advection</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">top_advec_bnd</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for top_advec_bnd</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module for topological advection with boundary.</span>

<span class="sd">This module contains child classes (derived from top_advec_base.py) that are</span>
<span class="sd">tailored to the case where particles remain in a bounded region</span>
<span class="sd">of the plane. The topological advection algorithm takes trajectories of point</span>
<span class="sd">particles in 2D and determines how this motion affects the state of material</span>
<span class="sd">curves in the surrounding medium.  Curves are encoded topologically as &#39;loops&#39;</span>
<span class="sd">with a triangulation of the points acting as a basis for the loops.  As the</span>
<span class="sd">points move, the triangulation is updated, and operators which act on loops</span>
<span class="sd">are accumulated.</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">Simplex2D</span>
<span class="sd">    Class representing a triangle / 2D simplex</span>

<span class="sd">Loop</span>
<span class="sd">    Class representing a topological loop or set of loops.</span>

<span class="sd">WeightOperator</span>
<span class="sd">    Class representing an operator that acts on loops.</span>

<span class="sd">PlotParameters:</span>
<span class="sd">    Data class for grouping plot parameters</span>

<span class="sd">Triangulation2D</span>
<span class="sd">    Class representing a triangulation of data points in a 2D domain.</span>
<span class="sd">    With methods for evolving the triangulation forward due to moving points,</span>
<span class="sd">    intializing loops, evolving loops, and plotting.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">PatchCollection</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">rcParams</span>
<span class="kn">from</span> <span class="nn">top_advec_base</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Simplex2D_Base</span><span class="p">,</span> <span class="n">Loop_Base</span><span class="p">,</span> <span class="n">WeightOperator_Base</span><span class="p">,</span>
                            <span class="n">Triangulation2D_Base</span><span class="p">,</span> <span class="n">PlotParameters</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">helper_fns</span> <span class="k">as</span> <span class="nn">HF</span>


<span class="c1"># Simplex2D class ############################################################</span>
<div class="viewcode-block" id="Simplex2D">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Simplex2D">[docs]</a>
<span class="k">class</span> <span class="nc">Simplex2D</span><span class="p">(</span><span class="n">Simplex2D_Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class representing a triangle / 2D simplex.</span>

<span class="sd">        (bounded domain version)</span>

<span class="sd">        (used in a 2D triangulation object)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    points : list of 3 ints</span>
<span class="sd">        List of the 3 vertex point IDs. These IDs will be used to get the</span>
<span class="sd">        vertex spatial locations from a master list that is a Triangulation2D</span>
<span class="sd">        attribue. Note that the order is only unique up to an even</span>
<span class="sd">        permutation. The permuation given on initialization is assumed to</span>
<span class="sd">        correspond to a set of geometric points that are given in counter</span>
<span class="sd">        clock-wise, CCW, order. Moving about this list (and other Simplex2D</span>
<span class="sd">        attributes) is done via modular arithmatic: (i+1)%3 to move CCW about</span>
<span class="sd">        the simplex from index i, and (i+2)%3 to move CW.</span>

<span class="sd">    simplices : list of 3 simplex objects</span>
<span class="sd">        List of the 3 simplices adjacent to this simplex. Convention: simplex</span>
<span class="sd">        at position i in this list is adjacent to this simplex at the edge</span>
<span class="sd">        across from self.points[i]</span>

<span class="sd">    edgeids : list of 3 ints</span>
<span class="sd">        List of the 3 edge ids. Each edge has an identifying integer that is</span>
<span class="sd">        used when keeping track of loop coordinates (in loop class).</span>

<span class="sd">    SLindex : int</span>
<span class="sd">        ID of this simplex in a Simplex List attribute of Triangulation2D</span>
<span class="sd">        (simplist). This is useful for going back and forth from the local</span>
<span class="sd">        view (Simplex2D object) and the global view (Triangulation2D object)</span>

<span class="sd">    IsBoundarySimp: bool</span>
<span class="sd">        IsBoundarySimp marks a simplex as being part of the boundary (True)</span>
<span class="sd">        if all point are boundary points.  Default is False.  Set when</span>
<span class="sd">        generating the triangulation</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    LocalID(IDin)</span>
<span class="sd">        Given the ID (IDin) of a vertex/point in this triangle, this returns</span>
<span class="sd">        the local ID, i.e. the integer i = 0,1,2 s.t. self.points[i] = IDin</span>

<span class="sd">    SimpNeighbors(IDin)</span>
<span class="sd">        Find the simplices about a given point. In the case of a boundary</span>
<span class="sd">        simplex (with None as one/two of the simplex neighbors), the list</span>
<span class="sd">        is not necessarily in CCW order.</span>

<span class="sd">    EdgeNeighbors(IDin)</span>
<span class="sd">        Find the ids of edges about a given point</span>

<span class="sd">    SimpLink(S_other)</span>
<span class="sd">        Link self with S_other simplex</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IDlist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the simplex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        IDlist : list of 3 ints</span>
<span class="sd">            List of the 3 point IDs from the master list (part of the</span>
<span class="sd">            tranguation class). It is assumed that IDlist already refers to</span>
<span class="sd">            points in the proper permutation (list order == ccw geometric</span>
<span class="sd">            order). Sets the points attribute.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Other attributes are set when linking them up in a Triangulation2D</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">IDlist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IsBoundarySimp</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Simplex2D.SimpNeighbors">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Simplex2D.SimpNeighbors">[docs]</a>
    <span class="k">def</span> <span class="nf">SimpNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IDin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the set of simpices which share a point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        IDin : int</span>
<span class="sd">            The ID of a vertex/point in this simplex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of Simplex2D objects</span>
<span class="sd">            the simplices (in CCW cyclical order about the shared point -</span>
<span class="sd">            IDin) adjacent to a point (IDin).  In the case of a boundary</span>
<span class="sd">            simplex (with None as one/two of the simplex neighbors), the list</span>
<span class="sd">            is not necessarily in CCW order.</span>

<span class="sd">        Note that this method requires that the simplex is connected up with</span>
<span class="sd">        other simplices in a triangulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">NeighborList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">LocalIDList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">IDin</span><span class="p">)</span>
        <span class="n">NeighborList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">LocalIDList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stpt</span><span class="p">)</span>
        <span class="n">lsimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">stpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">while</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lsimp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lsimp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">NeighborList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsimp</span><span class="p">)</span>
            <span class="n">lsimp_lid</span> <span class="o">=</span> <span class="n">lsimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">IDin</span><span class="p">)</span>
            <span class="n">LocalIDList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsimp_lid</span><span class="p">)</span>
            <span class="n">lsimp</span> <span class="o">=</span> <span class="n">lsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">lsimp_lid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lsimp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># this deals with the boundary simplex case</span>
            <span class="n">rsimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">stpt</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="k">while</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">rsimp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">rsimp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">NeighborList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rsimp</span><span class="p">)</span>
                <span class="n">rsimp_lid</span> <span class="o">=</span> <span class="n">rsimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">IDin</span><span class="p">)</span>
                <span class="n">LocalIDList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rsimp_lid</span><span class="p">)</span>
                <span class="n">rsimp</span> <span class="o">=</span> <span class="n">rsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">rsimp_lid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">NeighborList</span><span class="p">,</span> <span class="n">LocalIDList</span></div>


<div class="viewcode-block" id="Simplex2D.EdgeNeighbors">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Simplex2D.EdgeNeighbors">[docs]</a>
    <span class="k">def</span> <span class="nf">EdgeNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IDin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the edges which share a point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        IDin : int</span>
<span class="sd">            The ID of a vertex/point in this simplex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of ints</span>
<span class="sd">            the edge ids (in CCW cyclical order about the shared point -</span>
<span class="sd">            IDin) adjacent to a point (IDin).  In the case of a boundary</span>
<span class="sd">            simplex (with None as one/two of the simplex neighbors), the list</span>
<span class="sd">            is not necessarily in CCW order.</span>

<span class="sd">        Note that this method requires that the simplex is connected up with</span>
<span class="sd">        other simplices in a triangulation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">EdgeList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">IDin</span><span class="p">)</span>
        <span class="n">lsimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">stpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">EdgeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">stpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
        <span class="k">while</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lsimp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lsimp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">lsimp_lid</span> <span class="o">=</span> <span class="n">lsimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">IDin</span><span class="p">)</span>
            <span class="n">EdgeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">lsimp_lid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">lsimp</span> <span class="o">=</span> <span class="n">lsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">lsimp_lid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lsimp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># this deals with the boundary simplex case</span>
            <span class="n">rsimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">stpt</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="k">while</span> <span class="p">(</span><span class="bp">self</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">rsimp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">rsimp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">rsimp_lid</span> <span class="o">=</span> <span class="n">rsimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">IDin</span><span class="p">)</span>
                <span class="n">EdgeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">rsimp_lid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
                <span class="n">rsimp</span> <span class="o">=</span> <span class="n">rsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">rsimp_lid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">EdgeList</span></div>


<div class="viewcode-block" id="Simplex2D.SimpLink">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Simplex2D.SimpLink">[docs]</a>
    <span class="k">def</span> <span class="nf">SimpLink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S_other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Links this simplex with S_other (and vice versa).</span>

<span class="sd">        Used during an edge flip operation to ensure the newly created</span>
<span class="sd">        simplices are integrated into the triangulation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        S_other : Simplex2D object</span>
<span class="sd">            The simplex to link with self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">S_other</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Note that we don&#39;t need to do anything for linking a new</span>
            <span class="c1"># simplex to None ... it starts out that way</span>
            <span class="n">locid_s1</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">S_other</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_other</span>
                    <span class="n">locid_s1</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>
            <span class="n">locid_s2</span> <span class="o">=</span> <span class="p">(</span><span class="n">S_other</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locid_s1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
            <span class="n">S_other</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">locid_s2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span></div>
</div>

<span class="c1"># End of Simplex2D class #####################################################</span>


<span class="c1"># Loop Class #################################################################</span>
<div class="viewcode-block" id="Loop">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Loop">[docs]</a>
<span class="k">class</span> <span class="nc">Loop</span><span class="p">(</span><span class="n">Loop_Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class representing a topological loop or set of loops.</span>

<span class="sd">    The coordinate system (basis) for this representation is fixed by a</span>
<span class="sd">    particular Triangulation2D object.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    weightlist : list of ints/real numbers</span>
<span class="sd">        List of intersection coordinates for the loop.  Each location in the</span>
<span class="sd">        list corresponds to an edge in the Triangulation2D object (list index</span>
<span class="sd">        is edge id), and the list value at this index is the number of</span>
<span class="sd">        transverse intersections of our geometric loop (pulled &#39;tight&#39; for</span>
<span class="sd">        minimal intersection number) with the associated triangulation edge.</span>
<span class="sd">        A list of shear coordinates is also possible.</span>

<span class="sd">    Shear : bool</span>
<span class="sd">        Flag to denote the type of representation: False for regular</span>
<span class="sd">        intersection coordinates, and True for shear coordinates.  Shear</span>
<span class="sd">        coordinates allow us to create a &#39;mesh&#39; of bands along each edge,</span>
<span class="sd">        which is helpful for topological entropy calculations</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    GetWeightTotal()</span>
<span class="sd">        Returns the sum of the intersection coordinates (weights), which is a</span>
<span class="sd">        good proxy for the length of the loop.</span>

<span class="sd">    ProjectivizeWeights()</span>
<span class="sd">        Divides all the weights by the max weight value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tri</span><span class="p">,</span> <span class="n">rbands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">curves</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Shear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Loop.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tri : Triangulation2D object (really child class of Triangulation2D)</span>
<span class="sd">            tri is used as a basis with which the input curve options (rbands,</span>
<span class="sd">            curves, and mesh) are turned into intersection coordinates.</span>
<span class="sd">            Several tri methods are used to initialize weightlist.</span>

<span class="sd">        rbands : list of lists (of ints)</span>
<span class="sd">            rbands is a collection (outer list) of bands (inner lists). Each</span>
<span class="sd">            band is a list of point ids.  This list represents a CCW oriented</span>
<span class="sd">            loop in of the points in tri, with the loop going around a point</span>
<span class="sd">            on the side that makes a &#39;large&#39; (&gt;pi) angle with the lines</span>
<span class="sd">            connecting this point to the 2 adjacent points in the band.  Bands</span>
<span class="sd">            equvalent up to cyclic shifts of the points in the list. This is</span>
<span class="sd">            often used with just two point ids to create a band the goes from</span>
<span class="sd">            one point to another.</span>

<span class="sd">        curves : list of lists</span>
<span class="sd">            curves is a collection (outer list) of curves (inner lists). Each</span>
<span class="sd">            curve is a list with four elements: The first is a list of point</span>
<span class="sd">            positions (each point position is a list: [x,y]), which define a</span>
<span class="sd">            sequence of lines connected end to end. The second is a boolean</span>
<span class="sd">            (is_closed) which if signals that the point position list should</span>
<span class="sd">            wrap-around (True), or be considered a curve with end- points</span>
<span class="sd">            (False). The third is a pair (list) of 2 booleans which determine</span>
<span class="sd">            if we put a cap (circle around the closest point) around end 1 and</span>
<span class="sd">            end 2 of the curve. This is only relevant if the loop is not</span>
<span class="sd">            closed.  The final element is a number (wadd, can be int or float)</span>
<span class="sd">            that is the weight we add to crossed edges.</span>

<span class="sd">        Shear : bool</span>
<span class="sd">            Flag to denote the type of representation: False for regular</span>
<span class="sd">            intersection coordinates, and True for shear coordinates.</span>

<span class="sd">        mesh : bool</span>
<span class="sd">            If True, rbands and curves will be ignored, and the loop will be</span>
<span class="sd">            initialized in the &#39;mesh&#39; configuration, where each edge has a</span>
<span class="sd">            segment of the loop connecting adjacent points. Also sets</span>
<span class="sd">            Shear = True if True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            rbands is already a topological specification of a loop (points in</span>
<span class="sd">            tri), while curves are a geometric specification of a loop.</span>
<span class="sd">            Generally, avoid loops which trasversely intersect each other, as</span>
<span class="sd">            the way the &#39;X&#39; is reconnected is dependent on the local details</span>
<span class="sd">            of the triangulation.  However, intersections will still result</span>
<span class="sd">            in valid loop coordinates.</span>
<span class="sd">            Mesh is useful for picking up mixing thoughout the entire domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tri</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Shear</span> <span class="o">=</span> <span class="n">Shear</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                <span class="c1"># represents bands pinned to adjacent</span>
                <span class="c1"># points in this triangulation.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Shear</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># mesh must be evaluated with shear coordinates</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Shear</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rbands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tri</span><span class="o">.</span><span class="n">_BandWeightInitialize</span><span class="p">(</span><span class="n">rbands</span><span class="p">,</span> <span class="n">LoopIn</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">curves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tri</span><span class="o">.</span><span class="n">_CurveWeightInitialize</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">LoopIn</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">RegLoop</span> <span class="o">=</span> <span class="n">Loop</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rbands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tri</span><span class="o">.</span><span class="n">_BandWeightInitialize</span><span class="p">(</span><span class="n">rbands</span><span class="p">,</span> <span class="n">LoopIn</span><span class="o">=</span><span class="n">RegLoop</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">curves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tri</span><span class="o">.</span><span class="n">_CurveWeightInitialize</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">LoopIn</span><span class="o">=</span><span class="n">RegLoop</span><span class="p">)</span>
                <span class="c1">#  This first creates a regular loop (regular coordinates),</span>
                <span class="c1">#  then feeds this into the triangulation object to get the</span>
                <span class="c1">#  shear coordinates</span>
                <span class="n">tri</span><span class="o">.</span><span class="n">_ShearWeightInitialize</span><span class="p">(</span><span class="n">RegLoop</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Loop.GetWeightTotal">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Loop.GetWeightTotal">[docs]</a>
    <span class="k">def</span> <span class="nf">GetWeightTotal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Shear</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">WT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">)):</span>
                <span class="n">WT</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">WT</span></div>


<div class="viewcode-block" id="Loop.ProjectivizeWeights">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Loop.ProjectivizeWeights">[docs]</a>
    <span class="k">def</span> <span class="nf">ProjectivizeWeights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mwv</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">/</span><span class="n">mwv</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">]</span></div>


<div class="viewcode-block" id="Loop.LoopCopy">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Loop.LoopCopy">[docs]</a>
    <span class="k">def</span> <span class="nf">LoopCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
</div>

<span class="c1"># End of Loop Class ##########################################################</span>


<span class="c1"># WeightOperator Class #######################################################</span>
<div class="viewcode-block" id="WeightOperator">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.WeightOperator">[docs]</a>
<span class="k">class</span> <span class="nc">WeightOperator</span><span class="p">(</span><span class="n">WeightOperator_Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class representing an operator that acts on loops.</span>

<span class="sd">        It is generated every time a triangulation flip occurs during the</span>
<span class="sd">        evolution of a triangulation object, and holds the information needed</span>
<span class="sd">        to update the weightlist of a loop.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    eids : list of 5 ints</span>
<span class="sd">        The edge ids of the 5 elements in a loop weightlist whose</span>
<span class="sd">        corresponding triangulation edges surround a triangulation flip.</span>
<span class="sd">        For the quadrilateral whose diagonal edge will be flipped, the order</span>
<span class="sd">        of the edge ids in eids is: central diagonal first, then CCW perimeter</span>
<span class="sd">        edges, starting with an edge that, along with its quadrilateral</span>
<span class="sd">        opposite, form a &quot;Z&quot; with the central diagonal edge.</span>

<span class="sd">    time : real number</span>
<span class="sd">        the global time at which the flip happens</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    Update(LoopIn, Reverse = False)</span>
<span class="sd">        Updates the weightlist attribute of LoopIn</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IndexSet</span><span class="p">,</span> <span class="n">TimeIn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize WeightOperator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        IndexSet : list of (5) ints</span>
<span class="sd">            IndexSet contains the edge ids needed for updating a loop</span>
<span class="sd">            weightlist during a triangulation flip.</span>

<span class="sd">        TimeIn : real number</span>
<span class="sd">            the global time at which the flip happens</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eids</span> <span class="o">=</span> <span class="n">IndexSet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">TimeIn</span>

<div class="viewcode-block" id="WeightOperator.Update">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.WeightOperator.Update">[docs]</a>
    <span class="k">def</span> <span class="nf">Update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">Reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the weightlist attribute of LoopIn.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        LoopIn : Loop Object</span>
<span class="sd">            This is the loop whose weightlist will be updated (in place).</span>

<span class="sd">        Reverse : bool</span>
<span class="sd">            Reverse = True is used to evolve loops backwards in time.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">WL</span> <span class="o">=</span> <span class="p">[</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">LoopIn</span><span class="o">.</span><span class="n">Shear</span><span class="p">:</span>
            <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">WL</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">WL</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                                   <span class="n">WL</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">WL</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">-</span> <span class="n">WL</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># The main equation for updating intersection coordinates</span>
            <span class="c1"># Note that it workds equally well forward/backward in time</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For Shear weights, the surrounding quadrilateral weights</span>
            <span class="c1"># are also modified</span>
            <span class="n">Diag</span> <span class="o">=</span> <span class="n">WL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Diag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Diag</span>
                <span class="k">if</span> <span class="n">Diag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Reverse</span><span class="p">:</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Reverse</span><span class="p">:</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span></div>
</div>

<span class="c1"># End of WeightOperator Class ################################################</span>


<span class="c1"># PlotParameters Class ######################################################</span>
<div class="viewcode-block" id="PlotParameters">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.PlotParameters">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PlotParameters</span><span class="p">(</span><span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parameters for plotting.</span>

<span class="sd">    Class containing all of the parameters used in plotting the</span>
<span class="sd">    triangulation and loops, and their default values.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        The filename (including local path) to save the figure as.</span>
<span class="sd">        If None (default), then then the figure is printed to screen.</span>

<span class="sd">    triplot : bool</span>
<span class="sd">        Flag - prints the background triangulation if True (default) and</span>
<span class="sd">        excludes it if False.</span>

<span class="sd">    Delaunay : bool</span>
<span class="sd">        Flag - if True then uses Voronoi-based control points to draw the</span>
<span class="sd">        train-track representation of the loops.  If False (default), then</span>
<span class="sd">        triangle centers are used as control points.</span>

<span class="sd">    DelaunayAdd : bool</span>
<span class="sd">        Flag - A different Voronoi-based control point plotting system for</span>
<span class="sd">        the train-tracks.  This represents the train-track weights as line</span>
<span class="sd">        widths, which join naturally at train-track switch locations. This</span>
<span class="sd">        is only relevant if Delaunay is True.</span>

<span class="sd">    Bounds : list of lists</span>
<span class="sd">        Bounds has the format [[x_min, y_min],[x_max, y_max]], and determines</span>
<span class="sd">        the bounding box for plotting.  This is usually set automatically.</span>

<span class="sd">    FigureSizeX : float</span>
<span class="sd">        The width of the image in inches.  The height is automatically</span>
<span class="sd">        calculated based on Bounds.</span>

<span class="sd">    dpi : int</span>
<span class="sd">        The dots per inch.  Increase to increase the resolution and size of</span>
<span class="sd">        resulting image file.</span>

<span class="sd">    ptlabels : bool</span>
<span class="sd">        If True, the integer label for each point is plotted next to the</span>
<span class="sd">        point. False is default.  Mainly used for visually finding groups of</span>
<span class="sd">        points to encircle with a band.</span>

<span class="sd">    markersize : float</span>
<span class="sd">        Sets the markersize of the points.</span>

<span class="sd">    linewidth_tri : float</span>
<span class="sd">        The line width of the background triangulation.</span>

<span class="sd">    linecolor_tri : str</span>
<span class="sd">        The color of the triangulation lines. Default is &#39;g&#39; (green).</span>

<span class="sd">    color_weights : bool</span>
<span class="sd">        If True, then the individual segments of the train-track will be</span>
<span class="sd">        colored based on their weights.  This is one way to encode weight</span>
<span class="sd">        information in the plots.  Default is False.</span>

<span class="sd">    log_color : bool</span>
<span class="sd">        If True these colors will be assigned using the log of the weights. If</span>
<span class="sd">        False (default), the weights them-selves will determine the color</span>
<span class="sd">        scale</span>

<span class="sd">    color_map : str</span>
<span class="sd">        The color map to be used, default is &#39;inferno_r&#39;.</span>

<span class="sd">    linewidth_tt : float</span>
<span class="sd">        The line width of the train-track.  If DelaunayAdd is True, then this</span>
<span class="sd">        is the maximum line-width. Default is 1.0</span>

<span class="sd">    linecolor_tt : str</span>
<span class="sd">        The line color of the train-track. Default is &#39;r&#39; (red).</span>

<span class="sd">    alpha_tt : float</span>
<span class="sd">        The opacity of the train-track.  Default is 1.0 (completely</span>
<span class="sd">        opaque/not transparent).</span>

<span class="sd">    frac : float</span>
<span class="sd">        For plotting with the Delaunay flag, this determined how curved the</span>
<span class="sd">        train-tracks appear.  A value of 1.0 is maximally curvy (no linear</span>
<span class="sd">        segments), while a value of 0.0 would be just straight lines on</span>
<span class="sd">        following the Voronoi skeleton.  Default is 0.9</span>

<span class="sd">    tt_lw_min_frac : float</span>
<span class="sd">        The minimum fraction of linewidth_tt that will be represented.  This</span>
<span class="sd">        means that all train-track segments with weights below this fraction</span>
<span class="sd">        of the maximum weight will be represented as this fraction of</span>
<span class="sd">        linewidth_tt.  All segments with larger weight will have a line width</span>
<span class="sd">        that linear in this range.</span>

<span class="sd">    linewidth_curve : float</span>
<span class="sd">        The line width of the geometric curve. Default is 1.0</span>

<span class="sd">    linecolor_curve : str</span>
<span class="sd">        The line color of the geometric curve. Default is &#39;b&#39; (blue).</span>

<span class="sd">    alpha_curve : float</span>
<span class="sd">        The opacity of the geometric curve.  Default is 1.0 (completely</span>
<span class="sd">        opaque/not transparent).</span>

<span class="sd">    boundary_points : bool</span>
<span class="sd">        If true, this sets a larger boundary (in ExpandedBounds), which</span>
<span class="sd">        included the boundary control points.  Default is False.</span>

<span class="sd">    ExpandedBounds : list</span>
<span class="sd">        A larger boundary that includes the control points.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#  main flags/choices</span>
    <span class="n">Delaunay</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">DelaunayAdd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1">#  initial setup</span>
    <span class="n">Bounds</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">FigureSizeX</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">dpi</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="n">ptlabels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">markersize</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="n">linewidth_tri</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">linecolor_tri</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;g&#39;</span>
    <span class="n">color_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">log_color</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">color_map</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;inferno_r&#39;</span>
    <span class="c1">#  train track specifications</span>
    <span class="n">linewidth_tt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">linecolor_tt</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
    <span class="n">alpha_tt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="c1">#  Delaunay</span>
    <span class="n">frac</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span>
    <span class="c1">#  DelaunayAdd</span>
    <span class="n">tt_lw_min_frac</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">_conversion_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># internal only</span>
    <span class="n">_max_weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># internal only</span>
    <span class="n">linewidth_curve</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">linecolor_curve</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
    <span class="n">alpha_curve</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">boundary_points</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">ExpandedBounds</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="c1"># End of PlotParameters Class ###############################################</span>


<span class="c1"># Triangulation2D Class ######################################################</span>
<div class="viewcode-block" id="Triangulation2D">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Triangulation2D">[docs]</a>
<span class="k">class</span> <span class="nc">Triangulation2D</span><span class="p">(</span><span class="n">Triangulation2D_Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The central class in the overal Topological Advection algorithm.</span>

<span class="sd">    This class represents a triangulation of data points in a 2D</span>
<span class="sd">    domain.  It has methods for evolving the triangulation due to the</span>
<span class="sd">    motion of data points, acting as a basis for encoding loops,</span>
<span class="sd">    accumulating weight operators, and plotting.  This abstract base</span>
<span class="sd">    class then has different child classes for different situations</span>
<span class="sd">    (doubly periodic boundary conditions, given boundary, etc.).</span>

<span class="sd">    Note: Only the main attribues and methods are listed here.</span>

<span class="sd">    Note: The triangulation is initialized as a Delaunay triangulation.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pointlist : list</span>
<span class="sd">        A list of simplex objects.  Object at index i has the point with</span>
<span class="sd">        point id i in its point list.  Allows for O(1) lookup of points in the</span>
<span class="sd">        triangulation.  Note, not every simplex is in this list.</span>

<span class="sd">    pointpos : list</span>
<span class="sd">        A list of the [x,y] positions for the points at the current time</span>

<span class="sd">    _pointposfuture : list</span>
<span class="sd">        List of the [x,y] positions at the next time step.  Used with the</span>
<span class="sd">        Evolution method.</span>

<span class="sd">    simplist : list</span>
<span class="sd">        List of all of the simplices that make up the triangulation.</span>
<span class="sd">        Individual simplices have an id (SLindex) that indicates their</span>
<span class="sd">        location in this list.</span>

<span class="sd">    WeightOperatorList : list</span>
<span class="sd">        List of WeightOperator objects.  As the triangulation is evolved</span>
<span class="sd">        forward due to point motions, retriangulations with edge flips are</span>
<span class="sd">        needed.  For each flip, we record the data needed to evolve a loop</span>
<span class="sd">        forward.  This list is ordered (increasing) in time.</span>

<span class="sd">    Domain : list</span>
<span class="sd">        The rectangular domain that bounds the points.  This is used to set</span>
<span class="sd">        the boundary control points.  The format is:</span>
<span class="sd">        [[x_min, y_min],[x_max, y_max]]</span>


<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    Evolve(ptlist, Maintain_Delaunay = False)</span>
<span class="sd">        This evolves the triangulation forward due to the motion of the points</span>
<span class="sd">        - new point positions in ptlist. Options for evolution via collapse</span>
<span class="sd">        events or to maintain a Delaunay triangulation.  For every edge flip</span>
<span class="sd">        needed, a WeightOperator is added to the WeightOperator list.</span>

<span class="sd">    OperatorAction(LoopIn, index = None, Reverse = False, option = 3)</span>
<span class="sd">        This evolves forward an individual loop object (i.e. updates its</span>
<span class="sd">        weightlist due to the action of the WeightOperators in</span>
<span class="sd">        WeightOperatorList).</span>

<span class="sd">    Plot(LoopIn=None, GCurvesIn=None, PP: PlotParameters=PlotParameters())</span>
<span class="sd">        This plots the triangulation and loop.  See PlotParameters data class</span>
<span class="sd">        documentation for details on the many options.</span>

<span class="sd">    TriCopy(EvolutionReset = True)</span>
<span class="sd">        This returns a copy of this Triangulation2D object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptlist</span><span class="p">,</span> <span class="n">Domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Triangulation Initialization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ptlist : list</span>
<span class="sd">            ptlist is the list of [x,y] positions for the points at the</span>
<span class="sd">            initial time.</span>

<span class="sd">        Domain : list</span>
<span class="sd">            Domain = [[x_min,y_min],[x_max,y_max]]. The data points must be</span>
<span class="sd">            contained within this rectangular boundary at all times.  If</span>
<span class="sd">            None (Default), then this will be calculated from the max/min</span>
<span class="sd">            x/y values of the input ptlist.  Domain is used to generate the</span>
<span class="sd">            boundary control points.</span>

<span class="sd">        empty : bool</span>
<span class="sd">            Used for creating an empty object, which is then used for object</span>
<span class="sd">            copying.  Default is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extrapoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extranum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span> <span class="o">=</span> <span class="n">Domain</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_SetControlPoints</span><span class="p">(</span><span class="n">ptlist</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ptlist</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
            <span class="n">boundary_simp</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extranum</span><span class="p">:</span>
                    <span class="n">boundary_simp</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">boundary_simp</span><span class="p">:</span>
                <span class="n">simp</span><span class="o">.</span><span class="n">IsBoundarySimp</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_SetControlPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptlist</span><span class="p">):</span>
        <span class="c1">#  This sets the boundary control points based on the specified Domain</span>
        <span class="c1">#  Two concentric rectangles are created with linear point density</span>
        <span class="c1">#  equal to that of the ptlist data.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetBoundingDomainSlice</span><span class="p">(</span><span class="n">ptlist</span><span class="p">,</span> <span class="n">frac</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="c1">#  now find number of points along x and y boundary lines</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptlist</span><span class="p">)</span>
        <span class="n">Deltax</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Deltay</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">a_ratio</span> <span class="o">=</span> <span class="n">Deltax</span><span class="o">/</span><span class="n">Deltay</span>
        <span class="n">npts_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">npts</span><span class="o">*</span><span class="n">a_ratio</span><span class="p">)),</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">npts_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">npts</span><span class="o">/</span><span class="n">npts_x</span><span class="p">),</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">Deltax</span><span class="o">/</span><span class="p">(</span><span class="n">npts_x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">Deltay</span><span class="o">/</span><span class="p">(</span><span class="n">npts_y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>
        <span class="n">x_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">num</span><span class="o">=</span><span class="n">npts_x</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#  note: the arrays with a sqrt are used to force the outer rectangle</span>
        <span class="c1">#  to break degeneracy and be convex.</span>
        <span class="n">x_sety</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">npts_x</span><span class="p">,</span>
                                                  <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span><span class="o">*</span><span class="n">delta</span>
        <span class="n">y_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="n">npts_y</span><span class="p">,</span>
                            <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">y_setx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">npts_y</span><span class="p">,</span>
                                                <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span><span class="o">*</span><span class="n">delta</span>
        <span class="n">x_set2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">dx</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">dx</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                             <span class="n">num</span><span class="o">=</span><span class="n">npts_x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">x_sety2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">npts_x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                                 <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span><span class="o">*</span><span class="n">delta</span>
        <span class="n">y_set2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dy</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dy</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
                             <span class="n">num</span><span class="o">=</span><span class="n">npts_y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">y_setx2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">npts_y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                                 <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span><span class="o">*</span><span class="n">delta</span>
        <span class="n">Top1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x_set</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_sety</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_set</span><span class="p">))]</span>
        <span class="n">Bot1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x_set</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_sety</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_set</span><span class="p">))]</span>
        <span class="n">Top2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x_set2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x_sety2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_set2</span><span class="p">))]</span>
        <span class="n">Bot2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x_set2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dy</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x_sety2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_set2</span><span class="p">))]</span>
        <span class="n">Left1</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_setx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_set</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_set</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">Right1</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_setx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_set</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_set</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">Left2</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y_setx2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_set2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_set2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">Right2</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y_setx2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_set2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_set2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extrapoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">Top1</span> <span class="o">+</span> <span class="n">Bot1</span> <span class="o">+</span> <span class="n">Top2</span> <span class="o">+</span> <span class="n">Bot2</span>
                             <span class="o">+</span> <span class="n">Left1</span> <span class="o">+</span> <span class="n">Right1</span> <span class="o">+</span> <span class="n">Left2</span> <span class="o">+</span> <span class="n">Right2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extranum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extrapoints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptlist</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extranum</span>

    <span class="k">def</span> <span class="nf">_LoadPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptlist</span><span class="p">):</span>
        <span class="c1">#  Combining the bounding simplex points with the regular points&#39;</span>
        <span class="c1">#  positions (adding the extra point to the end rather than the</span>
        <span class="c1">#  begining is dicated by plotting concerns)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span> <span class="o">=</span> <span class="n">ptlist</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extrapoints</span>

    <span class="k">def</span> <span class="nf">_SetInitialTriangulation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#  This takes the set of points (including boundary control points),</span>
        <span class="c1">#  calculates the Delaunay Triangulation, creates and links the</span>
        <span class="c1">#  simplices, creates the pointlist, and sets the simplex edge ids</span>
        <span class="n">temppoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span>
        <span class="c1">#  create the initial Delaunay triangulation.  The option forces the</span>
        <span class="c1">#  creation of simplices for degenerate points by applying a random</span>
        <span class="c1">#  perturbation.</span>
        <span class="n">temptri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">temppoints</span><span class="p">,</span> <span class="n">qhull_options</span><span class="o">=</span><span class="s2">&quot;QJ Pp&quot;</span><span class="p">)</span>
        <span class="n">numsimp</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#  first create the list of Simplex2D objects</span>
        <span class="c1">#  not linked together yet - need to create every object first</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numsimp</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Simplex2D</span><span class="p">(</span><span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">SLindex</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1">#  now create the links</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numsimp</span><span class="p">):</span>
            <span class="n">linklist</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">linklist</span><span class="p">)):</span>
                <span class="c1">#  if -1 then the simplex already points to None</span>
                <span class="c1">#  true for neighbors of boundary simplices</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">linklist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">linklist</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SetPointList</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_SetEdgeIds</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_SetPointList</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#  creates the pointlist with links to individual simplices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">)]</span>
        <span class="c1">#  Go through each simplex and add that simplex to each slot in the</span>
        <span class="c1">#  pointlist that corresponds to an included point if the slot</span>
        <span class="c1">#  contains None (possibly more efficient way to do this)</span>
        <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">simp</span>

    <span class="k">def</span> <span class="nf">_SetEdgeIds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#  Assign each edge an index.</span>
        <span class="c1">#  The index is just taken from an incremental counter.</span>
        <span class="n">edgecounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgecounter</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">pt</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                        <span class="n">Lid</span> <span class="o">=</span> <span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
                        <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">Lid</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgecounter</span>
                    <span class="n">edgecounter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span> <span class="o">=</span> <span class="n">edgecounter</span>

<div class="viewcode-block" id="Triangulation2D.Evolve">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Triangulation2D.Evolve">[docs]</a>
    <span class="k">def</span> <span class="nf">Evolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptlist</span><span class="p">,</span> <span class="n">Maintain_Delaunay</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evolve the triangulation forward.</span>

<span class="sd">        Main method for evolving the state of the triangulation forward in</span>
<span class="sd">        time. This assumes that the starting triangulation is good</span>
<span class="sd">        (no negative areas).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ptlist : list</span>
<span class="sd">            The new time-slice data; the list of [x,y] positions for the</span>
<span class="sd">            points at the next time-step.</span>

<span class="sd">        Maintain_Delaunay : bool</span>
<span class="sd">            If Maintain_Delaunay is True (False is default), then after all</span>
<span class="sd">            of the collapse events are acounted for, extra edge flips will be</span>
<span class="sd">            used to ensure that the triangulation is Delaunay.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Overview: load the new positions, find the events, deal with the</span>
        <span class="c1">#  events, update the current position, and maintain delaunay if</span>
        <span class="c1">#  needed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LoadNewPos</span><span class="p">(</span><span class="n">ptlist</span><span class="p">)</span>
        <span class="n">EventLists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetEvents</span><span class="p">()</span>
        <span class="c1">#  GEvolve deals with the events in CollapseEventList</span>
        <span class="c1">#  and CrossingList (if periodic boundaries) in order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_GEvolve</span><span class="p">(</span><span class="n">EventLists</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_UpdatePtPos</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atstep</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">Maintain_Delaunay</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MakeDelaunay</span><span class="p">()</span></div>

            <span class="c1">#  after the atstep increment so that the operators</span>
            <span class="c1">#  will have the correct time-stamp.</span>

    <span class="k">def</span> <span class="nf">_LoadNewPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptlist</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span> <span class="o">=</span> <span class="n">ptlist</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extrapoints</span>

    <span class="k">def</span> <span class="nf">_GetEvents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#  Note that this wraps GetCollapseEvents so that it has the</span>
        <span class="c1">#  same signature at for the TopAdv_PBC case</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetCollapseEvents</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_GetCollapseEvents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find triangle collapse events.</span>

<span class="sd">        This finds all of the events where a triangle will go through zero</span>
<span class="sd">        area in the course of the points evolving from this time to the next</span>
<span class="sd">        time-step.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list of the simplices that collapse and the time of their</span>
<span class="sd">            collapse (bundled as a list of two items).  This list is sorted</span>
<span class="sd">            in decending order so that removing from the end (smallest times</span>
<span class="sd">            first) inccurs the smallest computational cost.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">collapsesimplist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Vec</span><span class="p">:</span>
            <span class="n">AZT_bool</span><span class="p">,</span> <span class="n">AZT_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AreaZeroTimeMultiple</span><span class="p">()</span>
            <span class="n">collapsesimplist</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">AZT_time</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">))</span>
                                <span class="k">if</span> <span class="n">AZT_bool</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
                <span class="n">AZT_bool</span><span class="p">,</span> <span class="n">AZT_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AreaZeroTimeSingle</span><span class="p">(</span><span class="n">simp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">AZT_bool</span><span class="p">:</span>
                    <span class="n">collapsesimplist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">simp</span><span class="p">,</span> <span class="n">AZT_time</span><span class="p">])</span>
        <span class="n">collapsesimplist</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">collapsesimplist</span>

    <span class="k">def</span> <span class="nf">_AreaZeroTimeSingle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimpIn</span><span class="p">,</span> <span class="n">Tin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate collapse time.</span>

<span class="sd">        Finds whether (and when) a triangle (simp) goes through zero area.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        simp : Simplex2D object</span>
<span class="sd">            The simplex to consider.</span>

<span class="sd">        Tin : float</span>
<span class="sd">            The lower bound on the time window to consider.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Returns a pair [IsSoln, TimeOut], where IsSoln is a boolean that</span>
<span class="sd">            is True if the first time at which the area goes through zero is</span>
<span class="sd">            between Tin and 1, and False if not. For IsSoln == True,</span>
<span class="sd">            TimeOut gives this time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Get the start and end x,y coordinate for each of the three points</span>
        <span class="n">ptlist</span> <span class="o">=</span> <span class="n">SimpIn</span><span class="o">.</span><span class="n">points</span>
        <span class="n">IP0x</span><span class="p">,</span> <span class="n">IP0y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">ptlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">IP1x</span><span class="p">,</span> <span class="n">IP1y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">ptlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">IP2x</span><span class="p">,</span> <span class="n">IP2y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">ptlist</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">FP0x</span><span class="p">,</span> <span class="n">FP0y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">ptlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">FP1x</span><span class="p">,</span> <span class="n">FP1y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">ptlist</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">FP2x</span><span class="p">,</span> <span class="n">FP2y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">ptlist</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">HF</span><span class="o">.</span><span class="n">AreaZeroTimeBaseSingle</span><span class="p">(</span><span class="n">IP0x</span><span class="p">,</span> <span class="n">IP0y</span><span class="p">,</span> <span class="n">IP1x</span><span class="p">,</span> <span class="n">IP1y</span><span class="p">,</span> <span class="n">IP2x</span><span class="p">,</span> <span class="n">IP2y</span><span class="p">,</span>
                                         <span class="n">FP0x</span><span class="p">,</span> <span class="n">FP0y</span><span class="p">,</span> <span class="n">FP1x</span><span class="p">,</span> <span class="n">FP1y</span><span class="p">,</span> <span class="n">FP2x</span><span class="p">,</span> <span class="n">FP2y</span><span class="p">,</span>
                                         <span class="n">Tin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_AreaZeroTimeMultiple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Tin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Vectorized calculation of collapse times.</span>

<span class="sd">        Goes through every simplex and looks for whether the area zero time</span>
<span class="sd">        is between Tin and 1.  Similar to AreaZeroTimeSingle, but wrapping up</span>
<span class="sd">        the info in numpy arrays to get vectorization and jit boost.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Tin : float</span>
<span class="sd">            The lower bound on the time window to consider.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of booleans, indicating whether the simplex (with this</span>
<span class="sd">            index) collapsed within the interval.</span>

<span class="sd">        list</span>
<span class="sd">            list of floats, giving the collapse times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nsimps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">)</span>
        <span class="n">pts0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pts2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">npptpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span>
        <span class="n">npptposf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">)</span>
        <span class="n">IP0x</span><span class="p">,</span> <span class="n">IP0y</span> <span class="o">=</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">IP1x</span><span class="p">,</span> <span class="n">IP1y</span> <span class="o">=</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">IP2x</span><span class="p">,</span> <span class="n">IP2y</span> <span class="o">=</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">FP0x</span><span class="p">,</span> <span class="n">FP0y</span> <span class="o">=</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">FP1x</span><span class="p">,</span> <span class="n">FP1y</span> <span class="o">=</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">FP2x</span><span class="p">,</span> <span class="n">FP2y</span> <span class="o">=</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">HF</span><span class="o">.</span><span class="n">AreaZeroTimeBaseVec</span><span class="p">(</span><span class="n">IP0x</span><span class="p">,</span> <span class="n">IP0y</span><span class="p">,</span> <span class="n">IP1x</span><span class="p">,</span> <span class="n">IP1y</span><span class="p">,</span> <span class="n">IP2x</span><span class="p">,</span> <span class="n">IP2y</span><span class="p">,</span>
                                      <span class="n">FP0x</span><span class="p">,</span> <span class="n">FP0y</span><span class="p">,</span> <span class="n">FP1x</span><span class="p">,</span> <span class="n">FP1y</span><span class="p">,</span> <span class="n">FP2x</span><span class="p">,</span> <span class="n">FP2y</span><span class="p">,</span> <span class="n">Tin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_GEvolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">EventLists</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process the events in EventLists.</span>

<span class="sd">        Processes an ordered list of events (collapse) and does edge flips to</span>
<span class="sd">        update the triangulation.  Also adds in new events as needed. Finished</span>
<span class="sd">        when there are no more events in the time interval, and the</span>
<span class="sd">        triangulation is consistent with the new set of points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">EventLists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">CollSimp</span><span class="p">,</span> <span class="n">currenttime</span> <span class="o">=</span> <span class="n">EventLists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#  deal with simplex collapse events here</span>
            <span class="n">newsimps</span><span class="p">,</span> <span class="n">delsimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SFix</span><span class="p">(</span><span class="n">CollSimp</span><span class="p">,</span> <span class="n">currenttime</span><span class="p">)</span>
            <span class="c1">#  returns ... [[leftsimp,rightsimp],topsimp (old)]</span>
            <span class="k">del</span> <span class="n">EventLists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># get rid of the evaluated event</span>
            <span class="c1">#  Find the time of zero area for simplex event</span>
            <span class="n">collapsed</span><span class="p">,</span> <span class="n">collapse_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AreaZeroTimeSingle</span><span class="p">(</span>
                <span class="n">delsimp</span><span class="p">,</span> <span class="n">currenttime</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">collapsed</span><span class="p">:</span>
                <span class="c1">#  and delete it if needed</span>
                <span class="n">HF</span><span class="o">.</span><span class="n">BinarySearchDel</span><span class="p">(</span><span class="n">EventLists</span><span class="p">,</span> <span class="p">[</span><span class="n">delsimp</span><span class="p">,</span> <span class="n">collapse_time</span><span class="p">])</span>
            <span class="c1">#  Go through the newsimps list and see if each object goes</span>
            <span class="c1">#  through zero area in the remaining time (if so, add to</span>
            <span class="c1">#  EventList with the calulated time to zero area)</span>
            <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="n">newsimps</span><span class="p">:</span>
                <span class="n">collapsed</span><span class="p">,</span> <span class="n">collapse_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AreaZeroTimeSingle</span><span class="p">(</span>
                    <span class="n">simp</span><span class="p">,</span> <span class="n">currenttime</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">collapsed</span><span class="p">:</span>
                    <span class="c1">#  insert in the event list at the correct spot</span>
                    <span class="n">HF</span><span class="o">.</span><span class="n">BinarySearchIns</span><span class="p">(</span><span class="n">EventLists</span><span class="p">,</span> <span class="p">[</span><span class="n">simp</span><span class="p">,</span> <span class="n">collapse_time</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_SFix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimpIn</span><span class="p">,</span> <span class="n">tcollapse</span><span class="p">):</span>
        <span class="c1">#  Fixing a simplex and the surrounding affected simplices. This</span>
        <span class="c1">#  returns the two new simplices, so that they can be possibly added</span>
        <span class="c1">#  to the local event list, also the bad simplex so it can be removed</span>
        <span class="c1">#  (if needed from the local event list)</span>

        <span class="c1">#  `colind` is the local index of the offending point during the</span>
        <span class="c1">#  area collapse</span>
        <span class="n">colind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CollapsePt</span><span class="p">(</span><span class="n">SimpIn</span><span class="p">,</span> <span class="n">tcollapse</span><span class="p">)</span>
        <span class="n">Topsimp</span> <span class="o">=</span> <span class="n">SimpIn</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">colind</span><span class="p">]</span>
        <span class="n">edge_id</span> <span class="o">=</span> <span class="n">SimpIn</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">colind</span><span class="p">]</span>
        <span class="n">globaltime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atstep</span> <span class="o">+</span> <span class="n">tcollapse</span>
        <span class="n">newsimps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EdgeFlip</span><span class="p">([</span><span class="n">SimpIn</span><span class="p">,</span> <span class="n">Topsimp</span><span class="p">],</span> <span class="n">edge_id</span><span class="p">,</span> <span class="n">globaltime</span><span class="p">)</span>
        <span class="c1">#  EdgeFlip does most of the work in flipping the edge and</span>
        <span class="c1">#  cleaning up linking</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">newsimps</span><span class="p">,</span> <span class="n">Topsimp</span><span class="p">]</span>
        <span class="c1">#  return the two new simplices, so that they can be checked to see</span>
        <span class="c1">#  if they need to be included in any update to the local event list.</span>
        <span class="c1">#  Also return the bad simplex to remove any instance from the</span>
        <span class="c1">#  event list.</span>

    <span class="k">def</span> <span class="nf">_CollapsePt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimpIn</span><span class="p">,</span> <span class="n">tcol</span><span class="p">):</span>
        <span class="c1">#  This returns the point (internal id) that passes through its</span>
        <span class="c1">#  opposite edge during an area collapse event known to occur</span>
        <span class="c1">#  at t = tcol</span>
        <span class="c1">#  first get the positions of the 3 points at the time of collapse</span>
        <span class="n">colpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetSimpCurrentLoc</span><span class="p">(</span><span class="n">SimpIn</span><span class="p">,</span> <span class="n">tcol</span><span class="p">)</span>
        <span class="n">d0</span> <span class="o">=</span> <span class="p">((</span><span class="n">colpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
              <span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1">#  This is the dot product of (z2-z0) and (z1-z0)</span>
        <span class="k">if</span> <span class="n">d0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="p">((</span><span class="n">colpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                  <span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">d1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="c1">#  Note: don&#39;t need to calculate the last dot product.</span>
            <span class="c1">#  If the first two are &gt;0, this must be &lt;0</span>

    <span class="k">def</span> <span class="nf">_GetSimpCurrentLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimpIn</span><span class="p">,</span> <span class="n">teval</span><span class="p">):</span>
        <span class="c1">#  This returns the linearly interpolated positions of each point in</span>
        <span class="c1">#  SimpIn at the time 0 &lt; teval &lt; 1.</span>
        <span class="n">ptlist</span> <span class="o">=</span> <span class="n">SimpIn</span><span class="o">.</span><span class="n">points</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_GetCurrentLoc</span><span class="p">(</span><span class="n">pt_ind</span><span class="p">,</span> <span class="n">teval</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_ind</span> <span class="ow">in</span> <span class="n">ptlist</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_GetCurrentLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt_ind</span><span class="p">,</span> <span class="n">teval</span><span class="p">):</span>
        <span class="n">posi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pt_ind</span><span class="p">]</span>
        <span class="n">posf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">pt_ind</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[((</span><span class="n">posf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">posi</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">*</span><span class="n">teval</span> <span class="o">+</span> <span class="n">posi</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_EdgeFlip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AdjSimps</span><span class="p">,</span> <span class="n">EdgeShare</span><span class="p">,</span> <span class="n">TimeIn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flip an edge in the triangulation.</span>

<span class="sd">        EdgeFlip locally re-triangulates the triangulation by removing an</span>
<span class="sd">        edge that divides two adjacent triangles in a quadrilateral, and</span>
<span class="sd">        replaces it with the other diagonal of this quadrilateral.  This</span>
<span class="sd">        removes the old simplices, creates new ones, and links them up in the</span>
<span class="sd">        triangulation. EdgeFlip also creates the appropriate WeightOperator</span>
<span class="sd">        object and adds it to the WeightOperator list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        AdjSimps : list of 2 Simplex2D objects</span>
<span class="sd">            These are the two simplices that share the edge to be flipped</span>

<span class="sd">        EdgeShare : int</span>
<span class="sd">            The edge id of the edge to be flipped.  While this can almost</span>
<span class="sd">            always be found from AdjSimps, the redundancy helps in certain</span>
<span class="sd">            cases.</span>

<span class="sd">        TimeIn : float</span>
<span class="sd">            This is the time when the event occured that required a flip.</span>
<span class="sd">            It is added as part of the data in the WeightOperator object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of 2 Simplex2D objects</span>
<span class="sd">            The two new simplices.  Returned so that the calling function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Simp</span><span class="p">,</span> <span class="n">Topsimp</span> <span class="o">=</span> <span class="n">AdjSimps</span>
        <span class="c1">#  local ids</span>
        <span class="n">bptlid</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">EdgeShare</span><span class="p">)</span>
        <span class="n">bpt</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">bptlid</span><span class="p">]</span>
        <span class="n">rptlid</span> <span class="o">=</span> <span class="p">(</span><span class="n">bptlid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
        <span class="n">lptlid</span> <span class="o">=</span> <span class="p">(</span><span class="n">bptlid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
        <span class="n">rpt</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">rptlid</span><span class="p">]</span>
        <span class="n">lpt</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">lptlid</span><span class="p">]</span>
        <span class="n">tptuid</span> <span class="o">=</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">EdgeShare</span><span class="p">)</span>
        <span class="n">tpt</span> <span class="o">=</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">tptuid</span><span class="p">]</span>
        <span class="n">lptuid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tptuid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
        <span class="n">rptuid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tptuid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
        <span class="c1">#  create the new simplices</span>
        <span class="n">rsimp</span> <span class="o">=</span> <span class="n">Simplex2D</span><span class="p">([</span><span class="n">bpt</span><span class="p">,</span> <span class="n">rpt</span><span class="p">,</span> <span class="n">tpt</span><span class="p">])</span>  <span class="c1"># new right simplex</span>
        <span class="n">lsimp</span> <span class="o">=</span> <span class="n">Simplex2D</span><span class="p">([</span><span class="n">bpt</span><span class="p">,</span> <span class="n">tpt</span><span class="p">,</span> <span class="n">lpt</span><span class="p">])</span>  <span class="c1"># new left simplex</span>
        <span class="c1">#  create the list of edge ids for the weight operator</span>
        <span class="n">WeightIDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">EdgeShare</span><span class="p">,</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">lptuid</span><span class="p">],</span>
                     <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">rptuid</span><span class="p">],</span> <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">rptlid</span><span class="p">],</span>
                     <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">lptlid</span><span class="p">]]</span>
        <span class="c1">#  create the weight operater and append to the list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">WeightOperator</span><span class="p">(</span><span class="n">WeightIDs</span><span class="p">,</span> <span class="n">TimeIn</span><span class="p">))</span>
        <span class="c1">#  create the links these simplices have to other simplices</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">Topsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">lptuid</span><span class="p">])</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">Topsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">rptuid</span><span class="p">])</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">Simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">lptlid</span><span class="p">])</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">Simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">rptlid</span><span class="p">])</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">lsimp</span><span class="p">)</span>
        <span class="c1">#  reassign the weight ids</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#  replace the two bad simplices in the simplex list</span>
        <span class="c1">#  with the two new ones</span>
        <span class="n">Simpindex</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">SLindex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">Simpindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsimp</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">SLindex</span> <span class="o">=</span> <span class="n">Simpindex</span>
        <span class="n">Topsimpindex</span> <span class="o">=</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">SLindex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">Topsimpindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsimp</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">SLindex</span> <span class="o">=</span> <span class="n">Topsimpindex</span>
        <span class="c1">#  look through the simplex point list to see if either of the</span>
        <span class="c1">#  bad simplices were there and if so, replace.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">bpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Simp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">bpt</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsimp</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">rpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Simp</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">rpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Topsimp</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">rpt</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsimp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">tpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Topsimp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">tpt</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsimp</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">lpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Simp</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">lpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Topsimp</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">lpt</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsimp</span>
        <span class="c1">#  Delete all the references to simplices in both of the bad simplices</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">Simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Topsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">lsimp</span><span class="p">,</span> <span class="n">rsimp</span><span class="p">]</span>

<div class="viewcode-block" id="Triangulation2D.MakeDelaunay">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Triangulation2D.MakeDelaunay">[docs]</a>
    <span class="k">def</span> <span class="nf">MakeDelaunay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flip edges until the triangulation is Delaunay.</span>

<span class="sd">        MakeDelaunay takes the current triangulation and, through a series</span>
<span class="sd">        of edge flips, changes it into the Delaunay triangulation for this</span>
<span class="sd">        point configuration.  This function changes the underlying</span>
<span class="sd">        triangulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">IsD</span><span class="p">,</span> <span class="n">InteriorEdge</span><span class="p">,</span> <span class="n">EdgeBSimps</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Vec</span><span class="p">:</span>  <span class="c1"># vectorized version (marginal improvements)</span>
            <span class="n">IsD</span><span class="p">,</span> <span class="n">InteriorEdge</span><span class="p">,</span> <span class="n">EdgeBSimps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsDelaunay</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">EdgeBSimps</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
            <span class="n">EdgeUsed</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
            <span class="n">IsD</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">simp</span><span class="o">.</span><span class="n">IsBoundarySimp</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">IsBoundarySimp</span><span class="p">:</span>
                            <span class="n">edgeid</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">EdgeUsed</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]:</span>
                                <span class="n">EdgeUsed</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="n">EdgeBSimps</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                                    <span class="p">[</span><span class="n">simp</span><span class="p">,</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">edgeid</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
                                <span class="n">IsD</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsLocallyDelaunay</span><span class="p">(</span>
                                    <span class="p">[</span><span class="n">simp</span><span class="p">,</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
            <span class="n">InteriorEdge</span> <span class="o">=</span> <span class="n">EdgeUsed</span>

        <span class="n">EdgeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">EdgeBSimps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">IsD</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">InteriorEdge</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">EdgeList_Epos</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeList</span><span class="p">)):</span>
            <span class="n">EdgeList_Epos</span><span class="p">[</span><span class="n">EdgeList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1">#  go through the edge list and start flipping edges</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">EdgeList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">EdgeSimps</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">,</span> <span class="n">checked</span> <span class="o">=</span> <span class="n">EdgeList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">EdgeList_Epos</span><span class="p">[</span><span class="n">edge_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">EdgeSimps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">IsBoundarySimp</span> <span class="ow">and</span>
                    <span class="ow">not</span> <span class="n">EdgeSimps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">IsBoundarySimp</span><span class="p">):</span>
                <span class="n">Flip</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">checked</span><span class="p">:</span>
                    <span class="n">Flip</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsLocallyDelaunay</span><span class="p">(</span><span class="n">EdgeSimps</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">Flip</span><span class="p">:</span>
                    <span class="n">LRsimps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EdgeFlip</span><span class="p">(</span><span class="n">EdgeSimps</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atstep</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># Left and right simplices</span>
                        <span class="n">loc</span> <span class="o">=</span> <span class="n">LRsimps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge_id</span><span class="p">)</span>
                        <span class="n">lrsimp</span> <span class="o">=</span> <span class="n">LRsimps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># upper and lower simplices</span>
                            <span class="n">eid</span> <span class="o">=</span> <span class="n">lrsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">loc</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">InteriorEdge</span><span class="p">[</span><span class="n">eid</span><span class="p">]:</span>
                                <span class="n">adjsimp</span> <span class="o">=</span> <span class="n">lrsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">loc</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                                <span class="n">ELinsert</span> <span class="o">=</span> <span class="p">[[</span><span class="n">lrsimp</span><span class="p">,</span> <span class="n">adjsimp</span><span class="p">],</span> <span class="n">eid</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
                                <span class="k">if</span> <span class="n">EdgeList_Epos</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="n">EdgeList_Epos</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">EdgeList</span><span class="p">)</span>
                                    <span class="n">EdgeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ELinsert</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">EdgeList</span><span class="p">[</span><span class="n">EdgeList_Epos</span><span class="p">[</span><span class="n">eid</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ELinsert</span></div>


    <span class="k">def</span> <span class="nf">_IsDelaunay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is the triangulation Delaunay.</span>

<span class="sd">        IsDelaunay outputs an array (length = number of edges) of booleans,</span>
<span class="sd">        which indicate if the quadrilateral with the ith edge as a diagonal is</span>
<span class="sd">        Delaunay. Also outputs an array of the pairs of simplices which bound</span>
<span class="sd">        each edge. This calls IsDelaunayBase (from a helper function module)</span>
<span class="sd">        for a jit speed-up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ax</span><span class="p">,</span> <span class="n">Ay</span><span class="p">,</span> <span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">,</span> <span class="n">Cx</span><span class="p">,</span> <span class="n">Cy</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)</span>
                                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>
        <span class="n">EdgeUsed</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
        <span class="n">BoundingSimps</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">simp</span><span class="o">.</span><span class="n">IsBoundarySimp</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">IsBoundarySimp</span><span class="p">:</span>
                        <span class="n">edgeid</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">EdgeUsed</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]:</span>
                            <span class="n">EdgeUsed</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">Apt</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                            <span class="n">Ax</span><span class="p">[</span><span class="n">edgeid</span><span class="p">],</span> <span class="n">Ay</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Apt</span><span class="p">]</span>
                            <span class="n">Bpt</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">Bx</span><span class="p">[</span><span class="n">edgeid</span><span class="p">],</span> <span class="n">By</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Bpt</span><span class="p">]</span>
                            <span class="n">Cpt</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                            <span class="n">Cx</span><span class="p">[</span><span class="n">edgeid</span><span class="p">],</span> <span class="n">Cy</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Cpt</span><span class="p">]</span>
                            <span class="n">adjsimp</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">BoundingSimps</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">simp</span><span class="p">,</span> <span class="n">adjsimp</span><span class="p">],</span>
                                                     <span class="n">edgeid</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
                            <span class="n">adjsimp_loc_id</span> <span class="o">=</span> <span class="n">adjsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edgeid</span><span class="p">)</span>
                            <span class="n">Dpt</span> <span class="o">=</span> <span class="n">adjsimp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">adjsimp_loc_id</span><span class="p">]</span>
                            <span class="n">Dx</span><span class="p">[</span><span class="n">edgeid</span><span class="p">],</span> <span class="n">Dy</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Dpt</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">HF</span><span class="o">.</span><span class="n">IsDelaunayBaseWMask</span><span class="p">(</span><span class="n">Ax</span><span class="p">,</span> <span class="n">Ay</span><span class="p">,</span> <span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">,</span> <span class="n">Cx</span><span class="p">,</span> <span class="n">Cy</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">,</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">EdgeUsed</span><span class="p">)),</span> <span class="n">EdgeUsed</span><span class="p">,</span>
                <span class="n">BoundingSimps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_IsLocallyDelaunay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AdjSimps</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is the quadrilateral Delaunay.</span>

<span class="sd">        Given the two adjacent simplices, this determine if the</span>
<span class="sd">        configuration is locally Delaunay.  Returns True or False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">simp1</span><span class="p">,</span> <span class="n">simp2</span> <span class="o">=</span> <span class="n">AdjSimps</span>
        <span class="n">locid</span> <span class="o">=</span> <span class="n">simp1</span><span class="o">.</span><span class="n">simplices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">simp2</span><span class="p">)</span>
        <span class="n">Apt</span> <span class="o">=</span> <span class="n">simp1</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">Ax</span><span class="p">,</span> <span class="n">Ay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Apt</span><span class="p">]</span>
        <span class="n">Bpt</span> <span class="o">=</span> <span class="n">simp1</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">locid</span><span class="p">]</span>
        <span class="n">Bx</span><span class="p">,</span> <span class="n">By</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Bpt</span><span class="p">]</span>
        <span class="n">Cpt</span> <span class="o">=</span> <span class="n">simp1</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">Cx</span><span class="p">,</span> <span class="n">Cy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Cpt</span><span class="p">]</span>
        <span class="n">locid2</span> <span class="o">=</span> <span class="n">simp2</span><span class="o">.</span><span class="n">simplices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">simp1</span><span class="p">)</span>
        <span class="n">Dpt</span> <span class="o">=</span> <span class="n">simp2</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">locid2</span><span class="p">]</span>
        <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Dpt</span><span class="p">]</span>
        <span class="n">ADx</span> <span class="o">=</span> <span class="n">Ax</span> <span class="o">-</span> <span class="n">Dx</span>
        <span class="n">ADy</span> <span class="o">=</span> <span class="n">Ay</span> <span class="o">-</span> <span class="n">Dy</span>
        <span class="n">BDx</span> <span class="o">=</span> <span class="n">Bx</span> <span class="o">-</span> <span class="n">Dx</span>
        <span class="n">BDy</span> <span class="o">=</span> <span class="n">By</span> <span class="o">-</span> <span class="n">Dy</span>
        <span class="n">CDx</span> <span class="o">=</span> <span class="n">Cx</span> <span class="o">-</span> <span class="n">Dx</span>
        <span class="n">CDy</span> <span class="o">=</span> <span class="n">Cy</span> <span class="o">-</span> <span class="n">Dy</span>
        <span class="n">AD2</span> <span class="o">=</span> <span class="n">ADx</span><span class="o">*</span><span class="n">ADx</span> <span class="o">+</span> <span class="n">ADy</span><span class="o">*</span><span class="n">ADy</span>
        <span class="n">BD2</span> <span class="o">=</span> <span class="n">BDx</span><span class="o">*</span><span class="n">BDx</span> <span class="o">+</span> <span class="n">BDy</span><span class="o">*</span><span class="n">BDy</span>
        <span class="n">CD2</span> <span class="o">=</span> <span class="n">CDx</span><span class="o">*</span><span class="n">CDx</span> <span class="o">+</span> <span class="n">CDy</span><span class="o">*</span><span class="n">CDy</span>
        <span class="n">detvals</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADx</span><span class="o">*</span><span class="p">(</span><span class="n">BDy</span><span class="o">*</span><span class="n">CD2</span> <span class="o">-</span> <span class="n">CDy</span><span class="o">*</span><span class="n">BD2</span><span class="p">)</span> <span class="o">-</span> <span class="n">ADy</span><span class="o">*</span><span class="p">(</span><span class="n">BDx</span><span class="o">*</span><span class="n">CD2</span> <span class="o">-</span> <span class="n">CDx</span><span class="o">*</span><span class="n">BD2</span><span class="p">)</span>
                   <span class="o">+</span> <span class="n">AD2</span><span class="o">*</span><span class="p">(</span><span class="n">BDx</span><span class="o">*</span><span class="n">CDy</span> <span class="o">-</span> <span class="n">CDx</span><span class="o">*</span><span class="n">BDy</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">detvals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="Triangulation2D.OperatorAction">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Triangulation2D.OperatorAction">[docs]</a>
    <span class="k">def</span> <span class="nf">OperatorAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">option</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flip operator acting on a Loop.</span>

<span class="sd">        OperatorAction takes the accumulated operator list stored in</span>
<span class="sd">        WeightOperatorList and operates sucessively on the given Loop</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        LoopIn : Loop Object</span>
<span class="sd">            The weightlist of this loop will be modified in place</span>

<span class="sd">        index : list of 2 ints</span>
<span class="sd">            the start and stop index can also be specified to break this up</span>
<span class="sd">            into stages (only used for option 1 and 2). Default is None</span>

<span class="sd">        Reverse : bool</span>
<span class="sd">            Reverse does the operator actions in reverse order (i.e. for</span>
<span class="sd">            loops in the final triangulation)</span>

<span class="sd">        option : int {1,2,3}</span>
<span class="sd">            option 1 just changes the data in the loop object</span>
<span class="sd">            option 2 also accumulates a weight list with the total weights</span>
<span class="sd">            after each operator has acted on the loop, and gives the global</span>
<span class="sd">            time of the operator action.</span>
<span class="sd">            option 3 (the default) returns a weight list which has the weights</span>
<span class="sd">            at the end of each time step (the intervals between each use of</span>
<span class="sd">            the Evolve method). This weight list does not have the time listed,</span>
<span class="sd">            as this is only know externally. this is most useful for producing</span>
<span class="sd">            a list that we can directly tie to an external list of times.</span>
<span class="sd">            This is what we need for extracting the topological entropy</span>
<span class="sd">            (hence the default option).</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        No return - option 1</span>
<span class="sd">        list of floats - option 2 and 3 (list is weightlist)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">startind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">endind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">startind</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">endind</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Reverse</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startind</span><span class="p">,</span> <span class="n">endind</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">endind</span><span class="p">,</span> <span class="n">startind</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">,</span> <span class="n">Reverse</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">WeightList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Reverse</span><span class="p">:</span>
                <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">(),</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startind</span><span class="p">,</span> <span class="n">endind</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">)</span>
                    <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">(),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">finaltime</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">(),</span> <span class="n">finaltime</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">endind</span><span class="p">,</span> <span class="n">startind</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">,</span> <span class="n">Reverse</span><span class="p">)</span>
                    <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">(),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">WeightList</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">WeightList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Reverse</span><span class="p">:</span>
                <span class="n">prevtime</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">)):</span>
                    <span class="n">thistime</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">thistime</span> <span class="o">&gt;</span> <span class="n">prevtime</span><span class="p">:</span>
                        <span class="n">prevtime</span> <span class="o">=</span> <span class="n">thistime</span>
                        <span class="n">currentweight</span> <span class="o">=</span> <span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">()</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">WeightList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thistime</span><span class="p">:</span>
                            <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentweight</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">)</span>
                <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                <span class="n">prevtime</span> <span class="o">=</span> <span class="n">endtime</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">thistime</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">thistime</span> <span class="o">&lt;</span> <span class="n">prevtime</span><span class="p">:</span>
                        <span class="n">prevtime</span> <span class="o">=</span> <span class="n">thistime</span>
                        <span class="n">currentweight</span> <span class="o">=</span> <span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">()</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">WeightList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">endtime</span><span class="o">-</span><span class="n">thistime</span><span class="p">:</span>
                            <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentweight</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">,</span> <span class="n">Reverse</span><span class="p">)</span>
                <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">num_times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">WeightList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_times</span><span class="p">:</span>
                    <span class="n">WL_last</span> <span class="o">=</span> <span class="n">WeightList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">WL_last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">WeightList</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Need to choose one of the options 1, 2, or 3&quot;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_BandWeightInitialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rbands</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a loop with band data.</span>

<span class="sd">        This initializes the edge weights in `LoopIn` that correspond to a</span>
<span class="sd">        given band (or set of bands) in `rbands`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rbands : list</span>
<span class="sd">            Each element in the list represents a band, and consists of two</span>
<span class="sd">            items: the list of points which define a band (see Loop class</span>
<span class="sd">            documentation), and the weight to add to the loop weightlist.</span>

<span class="sd">        LoopIn : Loop object</span>
<span class="sd">            The weightlist of `LoopIn` will be modified to represent this</span>
<span class="sd">            additional set of bands being added in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">band_data</span> <span class="ow">in</span> <span class="n">rbands</span><span class="p">:</span>
            <span class="n">band</span><span class="p">,</span> <span class="n">wadd</span> <span class="o">=</span> <span class="n">band_data</span>
            <span class="n">numpoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">band</span><span class="p">)</span>
            <span class="n">AreAdjacent</span><span class="p">,</span> <span class="n">CurveLeft</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpoints</span><span class="p">):</span>
                <span class="n">AreAdjacent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ArePointsAdjacent</span><span class="p">(</span><span class="n">band</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">band</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">]))</span>
                <span class="n">triplepts</span> <span class="o">=</span> <span class="p">[</span><span class="n">band</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="n">numpoints</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">],</span>
                             <span class="n">band</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">band</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">]]</span>
                <span class="n">CurveLeft</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_DoesCurveLeft</span><span class="p">(</span><span class="n">triplepts</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpoints</span><span class="p">):</span>
                <span class="n">Bool1</span> <span class="o">=</span> <span class="p">[</span><span class="n">CurveLeft</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">AreAdjacent</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                         <span class="n">CurveLeft</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">]]</span>
                <span class="n">Bool2</span> <span class="o">=</span> <span class="p">[</span><span class="n">AreAdjacent</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="n">numpoints</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">],</span>
                         <span class="n">CurveLeft</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">AreAdjacent</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="n">triplepts</span> <span class="o">=</span> <span class="p">[</span><span class="n">band</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="n">numpoints</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">],</span> <span class="n">band</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                             <span class="n">band</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_AddWeightsAlongLine</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">band</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">band</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">]],</span> <span class="n">Bool1</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">wadd</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_AddWeightsAroundPoint</span><span class="p">(</span><span class="n">triplepts</span><span class="p">,</span> <span class="n">Bool2</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">wadd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ArePointsAdjacent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="n">AreAdjacent</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">goodind</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extranum</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="n">IsBndryEdge</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">pt1</span> <span class="o">&gt;</span> <span class="n">goodind</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pt2</span> <span class="o">&gt;</span> <span class="n">goodind</span><span class="p">:</span>
                <span class="n">IsBndryEdge</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">temppt</span> <span class="o">=</span> <span class="n">pt1</span>
                <span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span>
                <span class="n">pt2</span> <span class="o">=</span> <span class="n">temppt</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">IsBndryEdge</span><span class="p">:</span>
            <span class="n">LRsimps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">LRsimpspos</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">simpposcounter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">StartSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">pt1</span><span class="p">]</span>
            <span class="n">locid</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pt2</span> <span class="ow">in</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                <span class="n">AreAdjacent</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">LRsimps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">StartSimp</span><span class="p">)</span>
                <span class="n">LRsimpspos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simpposcounter</span><span class="p">)</span>
            <span class="n">simpposcounter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">NextSimp</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">locid</span> <span class="o">=</span> <span class="n">NextSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">NextSimp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">StartSimp</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">LRsimpspos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pt2</span> <span class="ow">in</span> <span class="n">NextSimp</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                    <span class="n">AreAdjacent</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">LRsimps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NextSimp</span><span class="p">)</span>
                    <span class="n">LRsimpspos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simpposcounter</span><span class="p">)</span>
                <span class="n">simpposcounter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">NextSimp</span> <span class="o">=</span> <span class="n">NextSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">locid</span> <span class="o">=</span> <span class="n">NextSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">AreAdjacent</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">LRsimpspos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">LRsimpspos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">AreAdjacent</span><span class="p">,</span> <span class="p">[</span><span class="n">LRsimps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">LRsimps</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">AreAdjacent</span><span class="p">,</span> <span class="n">LRsimps</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">AreAdjacent</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_DoesCurveLeft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pttriple</span><span class="p">):</span>
        <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">pt3</span> <span class="o">=</span> <span class="n">pttriple</span>
        <span class="n">pos1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pt1</span><span class="p">]</span>
        <span class="n">pos2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pt2</span><span class="p">]</span>
        <span class="n">pos3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pt3</span><span class="p">]</span>
        <span class="n">crossP</span> <span class="o">=</span> <span class="p">((</span><span class="n">pos3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span>
                  <span class="p">(</span><span class="n">pos3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">crossP</span> <span class="o">&gt;=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_IsLeft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linepts</span><span class="p">,</span> <span class="n">ptin</span><span class="p">):</span>
        <span class="c1">#  this determines if the given point (ptin) is to the left of line</span>
        <span class="c1">#  that goes from the first to second point in linepts.</span>
        <span class="c1">#  Used in determining the edges crossed in an initial band</span>
        <span class="n">pttriple</span> <span class="o">=</span> <span class="p">[</span><span class="n">ptin</span><span class="p">,</span> <span class="n">linepts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">linepts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DoesCurveLeft</span><span class="p">(</span><span class="n">pttriple</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_AddWeightsAlongLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linepoints</span><span class="p">,</span> <span class="n">Boolin</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">wadd</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="c1">#  This takes the two points in linepoints and adds a weight of one</span>
        <span class="c1">#  (or non-default value) to any edges that are crossed by the line.</span>
        <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span> <span class="o">=</span> <span class="n">linepoints</span>
        <span class="k">if</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1">#  case of adjacent points (i.e. the line between the</span>
            <span class="c1">#  points is an edge). Only if the curvelefts&#39;</span>
            <span class="c1">#  (Boolin[0], Boolin[2]) are opposite one another,</span>
            <span class="c1">#  do we add a weight</span>
            <span class="k">if</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">pt1rtlocid</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
                <span class="n">edgeindex</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">pt1rtlocid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#  determine the direction (which simplex) to set out</span>
            <span class="c1">#  from that has pt1 as a point.</span>
            <span class="n">stlocid</span><span class="p">,</span> <span class="n">StartSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SimpInDir</span><span class="p">([</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">])</span>
            <span class="n">endlocid</span><span class="p">,</span> <span class="n">EndSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SimpInDir</span><span class="p">([</span><span class="n">pt2</span><span class="p">,</span> <span class="n">pt1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">pt2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                <span class="n">edgeindex</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">stlocid</span><span class="p">]</span>
                <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>
                <span class="n">leftpoint</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">stlocid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">CurrentSimp</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">stlocid</span><span class="p">]</span>
                <span class="n">leftptloc</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">leftpoint</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">CurrentSimp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">EndSimp</span><span class="p">:</span>
                    <span class="n">ptcompare</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">leftptloc</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">indexadd</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsLeft</span><span class="p">(</span><span class="n">linepoints</span><span class="p">,</span> <span class="n">ptcompare</span><span class="p">):</span>
                        <span class="n">indexadd</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">edgeindex</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">leftptloc</span><span class="o">+</span><span class="n">indexadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>
                    <span class="n">leftpoint</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">leftptloc</span><span class="o">+</span><span class="n">indexadd</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">CurrentSimp</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">leftptloc</span> <span class="o">+</span> <span class="n">indexadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">leftptloc</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">leftpoint</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_SimpInDir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linepoints</span><span class="p">):</span>
        <span class="c1">#  this returns the simplex (and local point id) that contains the</span>
        <span class="c1">#  first of linepoints, and has the line (to the second point)</span>
        <span class="c1">#  passing through it</span>
        <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span> <span class="o">=</span> <span class="n">linepoints</span>
        <span class="n">StartSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">pt1</span><span class="p">]</span>
        <span class="n">locpt</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="n">ptright</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">ptleft</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locpt</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="p">((</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsLeft</span><span class="p">([</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">],</span> <span class="n">ptright</span><span class="p">))</span> <span class="ow">and</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">_IsLeft</span><span class="p">([</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">],</span> <span class="n">ptleft</span><span class="p">)):</span>
            <span class="n">StartSimp</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">locpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">locpt</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
            <span class="n">ptright</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">ptleft</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locpt</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">locpt</span><span class="p">,</span> <span class="n">StartSimp</span>

    <span class="k">def</span> <span class="nf">_AddWeightsAroundPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pttriple</span><span class="p">,</span> <span class="n">Boolin</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">wadd</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1">#  This takes the central point in pttriple and adds in the weight</span>
        <span class="c1">#  of wadd to each of the radial edges starting from the edge that</span>
        <span class="c1">#  is part of the simplex bisected by pt1 and pt2, to the edge that</span>
        <span class="c1">#  is part of the simplex bisected by pt2 and pt3</span>
        <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">pt3</span> <span class="o">=</span> <span class="n">pttriple</span>
        <span class="n">indadd</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">indadd</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># curve right triggers this</span>
        <span class="n">stlocid</span><span class="p">,</span> <span class="n">StartSimp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">StartSimp</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">StartSimp</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">stlocid</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stlocid</span><span class="p">,</span> <span class="n">StartSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SimpInDir</span><span class="p">([</span><span class="n">pt2</span><span class="p">,</span> <span class="n">pt1</span><span class="p">])</span>
        <span class="n">endlocid</span><span class="p">,</span> <span class="n">EndSimp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">EndSimp</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">EndSimp</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">endlocid</span> <span class="o">=</span> <span class="n">EndSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endlocid</span><span class="p">,</span> <span class="n">EndSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SimpInDir</span><span class="p">([</span><span class="n">pt2</span><span class="p">,</span> <span class="n">pt3</span><span class="p">])</span>
        <span class="n">edgeindex</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">stlocid</span><span class="o">+</span><span class="n">indadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>
        <span class="n">CurrentSimp</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">stlocid</span><span class="o">+</span><span class="n">indadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">ptloc</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">CurrentSimp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">EndSimp</span><span class="p">:</span>
            <span class="n">edgeindex</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">ptloc</span><span class="o">+</span><span class="n">indadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>
            <span class="n">CurrentSimp</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">ptloc</span><span class="o">+</span><span class="n">indadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">ptloc</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_CurveWeightInitialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curves</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a loop with curve data.</span>

<span class="sd">        This initializes the edge weights in `LoopIn` that correspond to a</span>
<span class="sd">        given set of curves in `curves`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        curves : list</span>
<span class="sd">            Each element in the list represents a curve, and consists of four</span>
<span class="sd">            items: the list of point positions [[x_0,y_0],[x_1,y_1],...],</span>
<span class="sd">            whether the curve is closed (bool), whether the end points are</span>
<span class="sd">            pinned [bool,bool], and finally, the weight to add to the loop</span>
<span class="sd">            weightlist.</span>

<span class="sd">        LoopIn : Loop object</span>
<span class="sd">            The weightlist of LoopIn will be modified to represent this</span>
<span class="sd">            additional set of curves being added in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">:</span>
            <span class="n">point_set</span><span class="p">,</span> <span class="n">is_closed</span><span class="p">,</span> <span class="n">end_pts_pin</span><span class="p">,</span> <span class="n">wadd</span> <span class="o">=</span> <span class="n">curve</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Get_Edges</span><span class="p">(</span><span class="n">point_set</span><span class="p">,</span> <span class="n">is_closed</span><span class="p">,</span> <span class="n">end_pts_pin</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">:</span>
                <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>

    <span class="k">def</span> <span class="nf">_Simp_Hop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt_in</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">line_big</span><span class="p">,</span> <span class="n">edge_prev</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">next_edge</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#  see if pt_in is in simp.  If not, find edge intersection and then</span>
        <span class="c1">#  get adj simp, find ref point and dx,dy for shift that matches edge</span>
        <span class="c1">#  from simp. Then calls self recursively. Stops when simp is found</span>
        <span class="c1">#  with this point interior.  returns list of pairs [simp, edge] along</span>
        <span class="c1">#  path</span>
        <span class="c1">#  first see if pt_in is in the simp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tri_Contains</span><span class="p">(</span><span class="n">pt_in</span><span class="p">,</span> <span class="n">simp</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[[</span><span class="n">simp</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
                                 <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">])</span>
            <span class="n">next_id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">next_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">next_edge</span><span class="p">)</span>
                <span class="n">Line_simp</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">HF</span><span class="o">.</span><span class="n">IsIntersection</span><span class="p">(</span><span class="n">line_big</span><span class="p">,</span> <span class="n">Line_simp</span><span class="p">):</span>
                    <span class="n">next_id</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge_prev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="n">Line_simp</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">HF</span><span class="o">.</span><span class="n">IsIntersection</span><span class="p">(</span><span class="n">line_big</span><span class="p">,</span> <span class="n">Line_simp</span><span class="p">):</span>
                            <span class="n">next_id</span> <span class="o">=</span> <span class="n">i</span>
                            <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">edge_prev</span><span class="p">:</span>
                            <span class="n">Line_simp</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span>
                                         <span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="n">HF</span><span class="o">.</span><span class="n">IsIntersection</span><span class="p">(</span><span class="n">line_big</span><span class="p">,</span> <span class="n">Line_simp</span><span class="p">):</span>
                                <span class="n">next_id</span> <span class="o">=</span> <span class="n">i</span>
                                <span class="k">break</span>
            <span class="k">if</span> <span class="n">next_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span>
            <span class="n">next_simp</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[[</span><span class="n">simp</span><span class="p">,</span> <span class="n">edge</span><span class="p">]]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Simp_Hop</span><span class="p">(</span><span class="n">pt_in</span><span class="p">,</span> <span class="n">next_simp</span><span class="p">,</span> <span class="n">line_big</span><span class="p">,</span>
                                                   <span class="n">edge_prev</span><span class="o">=</span><span class="n">edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Tri_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">simp</span><span class="p">):</span>
        <span class="c1"># Determines whether the triangle (simp) contains pt.</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">])</span>
        <span class="n">trial_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">c_i</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">Curl</span><span class="p">(</span><span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                          <span class="n">trial_pt</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">c_i</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_Get_Edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end_pts_pin</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]):</span>
        <span class="c1">#  Finds the list of edges crossed by the curve represented by</span>
        <span class="c1">#  the list of points (points).</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">nn</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">simp_in</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_Find_Simp</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nn</span><span class="p">))]</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ncl</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">closed</span><span class="p">:</span>
            <span class="n">ncl</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">+</span><span class="n">ncl</span><span class="p">):</span>
            <span class="n">line_big</span> <span class="o">=</span> <span class="p">[</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">points</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)]]</span>
            <span class="n">simp_chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Simp_Hop</span><span class="p">(</span><span class="n">points</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)],</span>
                                        <span class="n">simp_in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">line_big</span><span class="p">)</span>
            <span class="n">edge_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">simp_chain</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">simp_chain</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">HF</span><span class="o">.</span><span class="n">Reduce_List</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">closed</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">end_pts_pin</span> <span class="o">==</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
            <span class="n">temp_edge_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">end_pts_pin</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">st_pt</span> <span class="o">=</span> <span class="n">simp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">temp_edge_list</span> <span class="o">+=</span> <span class="n">simp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">EdgeNeighbors</span><span class="p">(</span>
                    <span class="n">simp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">st_pt</span><span class="p">])</span>
            <span class="n">temp_edge_list</span> <span class="o">+=</span> <span class="n">edge_list</span>
            <span class="k">if</span> <span class="n">end_pts_pin</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">end_pt</span> <span class="o">=</span> <span class="n">simp_in</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">temp_edge_list</span> <span class="o">+=</span> <span class="n">simp_in</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">EdgeNeighbors</span><span class="p">(</span>
                    <span class="n">simp_in</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">end_pt</span><span class="p">])</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="n">temp_edge_list</span> <span class="o">+</span> <span class="n">edge_list</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">edge_list</span>

    <span class="k">def</span> <span class="nf">_Find_Simp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt_in</span><span class="p">,</span> <span class="n">nn_id</span><span class="p">):</span>
        <span class="c1">#  Finds the simplex which contains the input point</span>
        <span class="c1">#  uses the nearest neighbor point (nn_id)</span>
        <span class="n">simp_set</span><span class="p">,</span> <span class="n">l_id_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">nn_id</span><span class="p">]</span><span class="o">.</span><span class="n">SimpNeighbors</span><span class="p">(</span><span class="n">nn_id</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">simp_set</span><span class="p">)):</span>
            <span class="n">simp</span> <span class="o">=</span> <span class="n">simp_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">l_id</span> <span class="o">=</span> <span class="n">l_id_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">l_id</span><span class="p">]</span>
            <span class="n">line_big</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">nn_id</span><span class="p">]),</span> <span class="n">pt_in</span><span class="p">]</span>
            <span class="n">simp_chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Simp_Hop</span><span class="p">(</span><span class="n">pt_in</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">line_big</span><span class="p">,</span> <span class="n">next_edge</span><span class="o">=</span><span class="n">edge</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">simp_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">simp_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_ShearWeightInitialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RegLoop</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a loop a shear coordinate version of another loop.</span>

<span class="sd">        This takes the regular edge weights (for some band) encoded in</span>
<span class="sd">        `RegLoop`, and uses the triangulation connectivity to initialize</span>
<span class="sd">        `LoopIn`, which represents the band in shear coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        RegLoop : Loop object</span>
<span class="sd">            A loop already initialized with regular coordinates.</span>

<span class="sd">        LoopIn : Loop object</span>
<span class="sd">            The loop that will be initialized with shear coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="c1">#  LoopIn must be initialized to all zeros (this catches</span>
                <span class="c1">#  the second time through)</span>
                <span class="k">if</span> <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#  if the value for the regular loop is zero here, then</span>
                    <span class="c1">#  the shear coordinates should be zero</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">RegLoop</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">WA</span> <span class="o">=</span> <span class="n">RegLoop</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                        <span class="n">WB</span> <span class="o">=</span> <span class="n">RegLoop</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                        <span class="n">xsimp</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">Lid</span> <span class="o">=</span> <span class="n">xsimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
                        <span class="n">WC</span> <span class="o">=</span> <span class="n">RegLoop</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">xsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">Lid</span><span class="p">]]</span>
                        <span class="n">WD</span> <span class="o">=</span> <span class="n">RegLoop</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">xsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">Lid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">WA</span><span class="o">+</span><span class="n">WB</span><span class="o">-</span><span class="n">WC</span><span class="o">+</span><span class="n">WD</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>

    <span class="c1">#  Plotting</span>
    <span class="k">def</span> <span class="nf">_PlotPrelims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Preliminary setup for plotting.</span>

<span class="sd">        Handles the initial setup for the figure</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        PP : PlotParameters object</span>
<span class="sd">            For this method, the relevant PlotParameters attributes are:</span>

<span class="sd">        Bounds : list of lists</span>
<span class="sd">            Bounds has the format [[x_min, y_min],[x_max, y_max]], and</span>
<span class="sd">            determines the bounding box for plotting. This is usually set</span>
<span class="sd">            automatically.</span>

<span class="sd">        FigureSizeX : float</span>
<span class="sd">            The width of the image in inches.  The height is automatically</span>
<span class="sd">            calculated based on Bounds.</span>

<span class="sd">        dpi : int</span>
<span class="sd">            The dots per inch.  Increase to increase the resolution and size of</span>
<span class="sd">            resulting image file.</span>

<span class="sd">        boundary_points : bool</span>
<span class="sd">            If true, this sets a larger boundary (in ExpandedBounds), which</span>
<span class="sd">            included the boundary control points.  Default is False.</span>

<span class="sd">        ExpandedBounds : list</span>
<span class="sd">            A larger boundary that includes the control points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib fig object</span>
<span class="sd">            Not currently used, but might be used in the future to</span>
<span class="sd">            add another subplot</span>

<span class="sd">        ax : matplotlib axis object</span>
<span class="sd">            This is used to add features to the current plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">szx</span> <span class="o">=</span> <span class="n">PP</span><span class="o">.</span><span class="n">FigureSizeX</span>
        <span class="n">szy</span> <span class="o">=</span> <span class="n">szx</span>
        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">boundary_points</span> <span class="ow">and</span> <span class="n">PP</span><span class="o">.</span><span class="n">ExpandedBounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">szy</span> <span class="o">=</span> <span class="p">(</span><span class="n">szx</span><span class="o">*</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">ExpandedBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">PP</span><span class="o">.</span><span class="n">ExpandedBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span>
                   <span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">ExpandedBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">PP</span><span class="o">.</span><span class="n">ExpandedBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">szy</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">PP</span><span class="o">.</span><span class="n">dpi</span><span class="o">*</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">szy</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">dpi</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># szy*dpi must be even</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">boundary_points</span> <span class="ow">and</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">szy</span> <span class="o">=</span> <span class="p">(</span><span class="n">szx</span><span class="o">*</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span>
                   <span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">szy</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">PP</span><span class="o">.</span><span class="n">dpi</span><span class="o">*</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">szy</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">dpi</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># szy*dpi must be even</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">szx</span><span class="p">,</span> <span class="n">szy</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">dpi</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;savefig.pad_inches&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># to speed up plotting ... set smaller if needing higher quality</span>
        <span class="c1"># rcParams[&#39;path.simplify_threshold&#39;] = 1.0</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">boundary_points</span> <span class="ow">and</span> <span class="n">PP</span><span class="o">.</span><span class="n">ExpandedBounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="n">PP</span><span class="o">.</span><span class="n">ExpandedBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">ExpandedBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="n">PP</span><span class="o">.</span><span class="n">ExpandedBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">ExpandedBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">boundary_points</span> <span class="ow">and</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">labelbottom</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">labelleft</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">()</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">dpi_scale_trans</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="n">PP</span><span class="o">.</span><span class="n">_conversion_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">bbox</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">72</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">_TriangulationPlotBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the triangulation.</span>

<span class="sd">        Plots the underlying triangulation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis object</span>
<span class="sd">            The figure axis to add elements to</span>

<span class="sd">        PP : PlotParameters object</span>
<span class="sd">            For this method, the relevant PlotParameters attributes are:</span>

<span class="sd">        linewidth_tri : float</span>
<span class="sd">            The line width of the background triangulation.</span>

<span class="sd">        linecolor_tri : str</span>
<span class="sd">            The color of the triangulation lines. Default is &#39;g&#39; (green).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">boundary_points</span><span class="p">:</span>
            <span class="n">xpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span> <span class="o">-</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_extranum</span><span class="p">]]</span>
            <span class="c1">#  note that we exclude the bounding points</span>
            <span class="n">ypoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span> <span class="o">-</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_extranum</span><span class="p">]]</span>
            <span class="c1">#  make sure that the list of triangles (triplets of points) do</span>
            <span class="c1">#  not include the excluded boundary</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">points</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span> <span class="k">if</span>
                         <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                             <span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span>
                              <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extranum</span><span class="o">+</span><span class="mi">1</span><span class="p">)]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span><span class="n">xpoints</span><span class="p">,</span> <span class="n">ypoints</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">linecolor_tri</span><span class="p">,</span>
                       <span class="n">lw</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tri</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">]</span>
            <span class="n">ypoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">]</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">points</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span><span class="n">xpoints</span><span class="p">,</span> <span class="n">ypoints</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">linecolor_tri</span><span class="p">,</span>
                       <span class="n">lw</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tri</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_PointPlotBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the points.</span>

<span class="sd">        Plots the data points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis object</span>
<span class="sd">            The figure axis to add elements to</span>

<span class="sd">        PP : PlotParameters object</span>
<span class="sd">            For this method, the relevant PlotParameters attributes are:</span>

<span class="sd">        ptlabels : bool</span>
<span class="sd">            If True, the integer label for each point is plotted next to the</span>
<span class="sd">            point. False is default.  Mainly used for visually finding groups</span>
<span class="sd">            of points to encircle with a band.</span>

<span class="sd">        markersize : float</span>
<span class="sd">            Sets the markersize of the points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ptlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">boundary_points</span><span class="p">:</span>
            <span class="n">ptlen</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extranum</span>
        <span class="n">xpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[:</span><span class="n">ptlen</span><span class="p">]]</span>
        <span class="n">ypoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[:</span><span class="n">ptlen</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">ptlabels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xpoints</span><span class="p">)):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">xpoints</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">ypoints</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xpoints</span><span class="p">,</span> <span class="n">ypoints</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">markersize</span><span class="p">,</span>
                   <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_TTPlotBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the loop.</span>

<span class="sd">        Plots the train-track representation of the loop</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis object</span>
<span class="sd">            The figure axis to add elements to</span>

<span class="sd">        LoopIn : Loop object</span>
<span class="sd">            The data in LoopIn determine the train-track</span>

<span class="sd">        PP : PlotParameters object</span>
<span class="sd">            For this method, the relevant PlotParameters attributes are:</span>

<span class="sd">        Delaunay : bool</span>
<span class="sd">            Flag - if True then uses Voronoi-based control points to draw the</span>
<span class="sd">            train-track representation of the loops.  If False (default), then</span>
<span class="sd">            triangle centers are used as control points.</span>

<span class="sd">        DelaunayAdd : bool</span>
<span class="sd">            Flag - A different Voronoi-based control point plotting system for</span>
<span class="sd">            the train-tracks.  This represents the train-track weights as line</span>
<span class="sd">            widths, which join naturally at train-track switch locations. This</span>
<span class="sd">            is only relevant if Delaunay is True.</span>

<span class="sd">        color_weights : bool</span>
<span class="sd">            If True, then the individual segments of the train-track will be</span>
<span class="sd">            colored based on their weights.  This is one way to encode weight</span>
<span class="sd">            information in the plots.  Default is False.</span>

<span class="sd">        log_color : bool</span>
<span class="sd">            If True these colors will be assigned using the log of the</span>
<span class="sd">            weights. If False (default), the weights them-selves will</span>
<span class="sd">            determine the color scale.</span>

<span class="sd">        color_map : str</span>
<span class="sd">            The color map to be used, default is &#39;inferno_r&#39;.</span>

<span class="sd">        linewidth_tt : float</span>
<span class="sd">            The line width of the train-track.  If DelaunayAdd is True, then</span>
<span class="sd">            this is the maximum line-width</span>

<span class="sd">        linecolor_tt : str</span>
<span class="sd">            The line color of the train-track. Default is &#39;r&#39; (red).</span>

<span class="sd">        alpha_tt : float</span>
<span class="sd">            The opacity of the train-track.  Default is 1.0 (completely</span>
<span class="sd">            opaque/not transparent).</span>

<span class="sd">        frac : float</span>
<span class="sd">            For plotting with the Delaunay flag, this determined how curved</span>
<span class="sd">            the train-tracks appear.  A value of 1.0 is maximally curvy (no</span>
<span class="sd">            linear segments), while a value of 0.0 would be just straight</span>
<span class="sd">            lines on following the Voronoi skeleton.  Default is 0.9</span>

<span class="sd">        tt_lw_min_frac : float</span>
<span class="sd">            The minimum fraction of linewidth_tt that will be represented.</span>
<span class="sd">            This means that all train-track segments with weights below this</span>
<span class="sd">            fraction of the maximum weight will be represented as this</span>
<span class="sd">            fraction of linewidth_tt.  All segments with larger weight will</span>
<span class="sd">            have a line width that linear in this range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  keeps track of segments that have been plotted</span>
        <span class="c1">#  (so as to not plot an element twice)</span>
        <span class="n">EdgePlotted</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
        <span class="n">ttpatches</span><span class="p">,</span> <span class="n">cweights</span><span class="p">,</span> <span class="n">line_widths</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">Delaunay</span><span class="p">:</span>   <span class="c1"># regular case, works for any triangulation</span>
            <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">simp</span><span class="o">.</span><span class="n">IsBoundarySimp</span><span class="p">:</span>
                    <span class="n">new_ttpatches</span><span class="p">,</span> <span class="n">new_cweights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GeneralSimplexTTPlot</span><span class="p">(</span>
                        <span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">EdgePlotted</span><span class="p">,</span> <span class="n">PP</span><span class="p">)</span>
                    <span class="n">ttpatches</span> <span class="o">+=</span> <span class="n">new_ttpatches</span>
                    <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                        <span class="n">cweights</span> <span class="o">+=</span> <span class="n">new_cweights</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># looks nicer, but only works for a Delaunay triangulation</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">DelaunayAdd</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">simp</span><span class="o">.</span><span class="n">IsBoundarySimp</span><span class="p">:</span>
                        <span class="n">new_ttpatches</span><span class="p">,</span> <span class="n">new_cweights</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_DelaunaySimplexTTPlot</span><span class="p">(</span><span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span>
                                                        <span class="n">EdgePlotted</span><span class="p">,</span> <span class="n">PP</span><span class="p">))</span>
                        <span class="n">ttpatches</span> <span class="o">+=</span> <span class="n">new_ttpatches</span>
                        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                            <span class="n">cweights</span> <span class="o">+=</span> <span class="n">new_cweights</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">PP</span><span class="o">.</span><span class="n">_max_weight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">simp</span><span class="o">.</span><span class="n">IsBoundarySimp</span><span class="p">:</span>
                        <span class="n">new_ttpatches</span><span class="p">,</span> <span class="n">new_cweights</span><span class="p">,</span> <span class="n">new_l_widths</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_DelaunaySimplexTTPlot_exp</span><span class="p">(</span><span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">PP</span><span class="p">))</span>
                        <span class="n">ttpatches</span> <span class="o">+=</span> <span class="n">new_ttpatches</span>
                        <span class="n">line_widths</span> <span class="o">+=</span> <span class="n">new_l_widths</span>
                        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                            <span class="n">cweights</span> <span class="o">+=</span> <span class="n">new_cweights</span>
        <span class="n">Pcollection</span> <span class="o">=</span> <span class="n">PatchCollection</span><span class="p">(</span><span class="n">ttpatches</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">alpha_tt</span><span class="p">,</span>
                                      <span class="n">capstyle</span><span class="o">=</span><span class="s1">&#39;butt&#39;</span><span class="p">,</span> <span class="n">joinstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span>
                                      <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">DelaunayAdd</span><span class="p">:</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">line_widths</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linecolor_tt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">log_color</span><span class="p">:</span>
                <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cweights</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">cweights</span><span class="p">)</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">color_map</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">Pcollection</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_GeneralSimplexTTPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">EdgePlotted</span><span class="p">,</span>
                              <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
        <span class="c1">#  plot the segments of train tracks that are determined from a</span>
        <span class="c1">#  given simplex</span>
        <span class="n">patches_out</span><span class="p">,</span> <span class="n">weights_out</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">]</span>  <span class="c1"># edge weights</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>  <span class="c1"># if there are any weights to plot</span>
            <span class="c1">#  locations of the three simplex vertices</span>
            <span class="n">vertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pts</span><span class="p">]</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">])</span>
            <span class="c1">#  local id of the extra point in each of the 3 surrounding</span>
            <span class="c1">#  simplices</span>
            <span class="n">exlids</span> <span class="o">=</span> <span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1">#  locations of the extra point in each of the 3 surrounding</span>
            <span class="c1">#  simplices</span>
            <span class="n">exvertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">exlids</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1">#  now let&#39;s get the simplex geometric centers and</span>
            <span class="c1">#  edge halfwaypoints</span>
            <span class="n">SimpCenter</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">(</span><span class="n">vertpts</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">AdjSimpCenters</span> <span class="o">=</span> <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vertpts</span><span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">exvertpts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                 <span class="n">vertpts</span><span class="p">[(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="n">EdgeHalf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">([</span><span class="n">vertpts</span><span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vertpts</span><span class="p">[(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]])</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1">#  now the points that are halfway between the edge</span>
            <span class="c1">#  centers and the simpcenter</span>
            <span class="n">CenterEdgeHalf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">([</span><span class="n">SimpCenter</span><span class="p">,</span> <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1">#  now the points that are halfway between the edge centers</span>
            <span class="c1">#  and the adjacent simplex centers</span>
            <span class="n">AdjEdgeHalf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">([</span><span class="n">AdjSimpCenters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1">#  check that the quadratic Bezier control triangle doesn&#39;t</span>
            <span class="c1">#  contain a vertex.</span>
            <span class="c1">#  If so, we modify the control points</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">side</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># default is left</span>
                <span class="n">C1</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">Curl</span><span class="p">(</span><span class="n">AdjEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                             <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">CenterEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">if</span> <span class="n">C1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">side</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># right</span>
                <span class="n">Line1</span> <span class="o">=</span> <span class="p">[</span><span class="n">CenterEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">AdjEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]]</span>
                <span class="n">Line2</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertpts</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">side</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]]</span>
                <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetIntersectionTimes</span><span class="p">(</span><span class="n">Line1</span><span class="p">,</span> <span class="n">Line2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">t2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># need to modify</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="o">-</span><span class="n">t2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t2</span><span class="p">)</span>
                    <span class="n">CenterEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">CenterEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                                            <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">AdjEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">AdjEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                                         <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="c1">#  the interior weights</span>
            <span class="n">Wp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">EdgePlotted</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                    <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                        <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">HF</span><span class="o">.</span><span class="n">BezierQuad</span><span class="p">(</span><span class="n">CenterEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                                          <span class="n">AdjEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
                        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                            <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">EdgePlotted</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                    <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">HF</span><span class="o">.</span><span class="n">BezierQuad</span><span class="p">(</span><span class="n">CenterEdgeHalf</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span>
                                      <span class="n">SimpCenter</span><span class="p">,</span>
                                      <span class="n">CenterEdgeHalf</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]))</span>
                    <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                        <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">patches_out</span><span class="p">,</span> <span class="n">weights_out</span>

    <span class="k">def</span> <span class="nf">_DelaunaySimplexTTPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">EdgePlotted</span><span class="p">,</span> <span class="n">PP</span><span class="p">):</span>
        <span class="c1">#  used in other function to plot the segments of train tracks that</span>
        <span class="c1">#  are determined from a given simplex this version assumes the</span>
        <span class="c1">#  triangulation is Delaunay, and uses the dual Voroni Centers as</span>
        <span class="c1">#  control points</span>
        <span class="n">patches_out</span><span class="p">,</span> <span class="n">weights_out</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">]</span>  <span class="c1"># edge weights</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>  <span class="c1"># if there are any weights to plot</span>
            <span class="c1">#  locations of the three simplex vertices</span>
            <span class="n">vertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pts</span><span class="p">]</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">])</span>
            <span class="c1">#  local id of the extra point in each of the 3</span>
            <span class="c1">#  surrounding simplices</span>
            <span class="n">exlids</span> <span class="o">=</span> <span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1">#  locations of the extra point in each of the 3</span>
            <span class="c1">#  surrounding simplices</span>
            <span class="n">exvertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">exlids</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1">#  now let&#39;s get the simplex Voronoi centers and halfwaypoints</span>
            <span class="n">SimpVCenter</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetCircumCircleCenter</span><span class="p">(</span><span class="n">vertpts</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">AdjSimpVCenters</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HF</span><span class="o">.</span><span class="n">GetCircumCircleCenter</span><span class="p">([</span><span class="n">vertpts</span><span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span>
                                          <span class="n">exvertpts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                                          <span class="n">vertpts</span><span class="p">[(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1">#  halfway between Voronoi centers</span>
            <span class="n">HalfVCs</span> <span class="o">=</span> <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">([</span><span class="n">SimpVCenter</span><span class="p">,</span> <span class="n">AdjSimpVCenters</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1">#  now the points that partway (frac - default = 0.5) from</span>
            <span class="c1">#  Center voroni to HalfVCs</span>
            <span class="n">FracControlPts_In</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">LinFuncInterp</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">,</span> <span class="n">HalfVCs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">frac</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">FracControlPts_Out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">LinFuncInterp</span><span class="p">(</span><span class="n">AdjSimpVCenters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">HalfVCs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">frac</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1">#  the interior weights</span>
            <span class="n">Wp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">EdgePlotted</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                    <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                        <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">HF</span><span class="o">.</span><span class="n">BezierLinear</span><span class="p">(</span><span class="n">FracControlPts_In</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                                            <span class="n">FracControlPts_Out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
                        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                            <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">EdgePlotted</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                    <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">HF</span><span class="o">.</span><span class="n">BezierQuad</span><span class="p">(</span><span class="n">FracControlPts_In</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span>
                                      <span class="n">SimpVCenter</span><span class="p">,</span>
                                      <span class="n">FracControlPts_In</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]))</span>
                    <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                        <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">patches_out</span><span class="p">,</span> <span class="n">weights_out</span>

    <span class="k">def</span> <span class="nf">_DelaunaySimplexTTPlot_exp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">PP</span><span class="p">):</span>
        <span class="c1">#  used in other function to plot the segments of train tracks that</span>
        <span class="c1">#  are determined from a given simplex this version assumes the</span>
        <span class="c1">#  triangulation is Delaunay, and uses the dual Voroni Centers as</span>
        <span class="c1">#  control points this is an experimental version, where I work on</span>
        <span class="c1">#  ideas before incorporating them into the main plotting</span>
        <span class="n">patches_out</span><span class="p">,</span> <span class="n">weights_out</span><span class="p">,</span> <span class="n">line_weights_out</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">]</span>  <span class="c1"># edge weights</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>  <span class="c1"># if there are any weights to plot</span>
            <span class="c1">#  locations of the three simplex vertices</span>
            <span class="n">vertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pts</span><span class="p">]</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">])</span>
            <span class="c1">#  local id of the extra point in each of the 3</span>
            <span class="c1">#  surrounding simplices</span>
            <span class="n">exlids</span> <span class="o">=</span> <span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1">#  locations of the extra point in each of the 3</span>
            <span class="c1">#  surrounding simplices</span>
            <span class="n">exvertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">exlids</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1">#  now let&#39;s get the simplex Voronoi centers and halfwaypoints</span>
            <span class="n">SimpVCenter</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetCircumCircleCenter</span><span class="p">(</span><span class="n">vertpts</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">AdjSimpVCenters</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">HF</span><span class="o">.</span><span class="n">GetCircumCircleCenter</span><span class="p">([</span><span class="n">vertpts</span><span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span>
                                          <span class="n">exvertpts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                                          <span class="n">vertpts</span><span class="p">[(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1">#  halfway between Voronoi centers</span>
            <span class="n">HalfVCs</span> <span class="o">=</span> <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">([</span><span class="n">SimpVCenter</span><span class="p">,</span> <span class="n">AdjSimpVCenters</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1">#  now the points that partway (frac - default = 0.5)</span>
            <span class="c1">#  from Center voroni to HalfVCs</span>
            <span class="n">FracControlPts_In</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">LinFuncInterp</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">,</span> <span class="n">HalfVCs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">frac</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1"># FracControlPts_Out = np.array(</span>
            <span class="c1">#    [HF.LinFuncInterp(AdjSimpVCenters[i], HalfVCs[i], PP.frac)</span>
            <span class="c1">#     for i in range(3)])</span>
            <span class="c1"># the interior weights</span>
            <span class="n">Wp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="n">W_scaled</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">Wp_scaled</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">PP</span><span class="o">.</span><span class="n">_max_weight</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">tt_lw_min_frac</span><span class="p">:</span>
                    <span class="n">W_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tt</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">tt_lw_min_frac</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">W_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tt</span><span class="o">*</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">PP</span><span class="o">.</span><span class="n">_max_weight</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">PP</span><span class="o">.</span><span class="n">_max_weight</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">tt_lw_min_frac</span><span class="p">:</span>
                    <span class="n">Wp_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tt</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">tt_lw_min_frac</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Wp_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tt</span><span class="o">*</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">PP</span><span class="o">.</span><span class="n">_max_weight</span><span class="p">))</span>
            <span class="c1">#  now find the modified control points</span>
            <span class="n">rmp90</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">rmm90</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">FCP_m_center</span> <span class="o">=</span> <span class="n">FracControlPts_In</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">)</span>
            <span class="n">FCP_m_center_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">FCP_m_center</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">FCP_m_center</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">displace_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">W_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Wp_scaled</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span>
                 <span class="n">PP</span><span class="o">.</span><span class="n">_conversion_factor</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">displace_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">W_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Wp_scaled</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span>
                 <span class="n">PP</span><span class="o">.</span><span class="n">_conversion_factor</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">FCP_m_center_rotp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rmp90</span><span class="p">,</span> <span class="n">FCP_m_center</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">FCP_m_center_rotm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rmm90</span><span class="p">,</span> <span class="n">FCP_m_center</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">scaling_l</span> <span class="o">=</span> <span class="n">displace_l</span><span class="o">/</span><span class="n">FCP_m_center_mag</span>
            <span class="n">scaling_r</span> <span class="o">=</span> <span class="n">displace_r</span><span class="o">/</span><span class="n">FCP_m_center_mag</span>
            <span class="n">delta_vec_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">FCP_m_center_rotp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">scaling_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">delta_vec_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">FCP_m_center_rotm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">scaling_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">FCP_mod_l</span> <span class="o">=</span> <span class="n">delta_vec_l</span> <span class="o">+</span> <span class="n">FracControlPts_In</span>
            <span class="n">FCP_mod_r</span> <span class="o">=</span> <span class="n">delta_vec_r</span> <span class="o">+</span> <span class="n">FracControlPts_In</span>
            <span class="n">Center_mod_l</span> <span class="o">=</span> <span class="n">delta_vec_l</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">)</span>
            <span class="n">Center_mod_r</span> <span class="o">=</span> <span class="n">delta_vec_r</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">)</span>
            <span class="n">HalfVCs_mod_l</span> <span class="o">=</span> <span class="n">delta_vec_l</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">HalfVCs</span><span class="p">)</span>
            <span class="n">HalfVCs_mod_r</span> <span class="o">=</span> <span class="n">delta_vec_r</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">HalfVCs</span><span class="p">)</span>
            <span class="n">center_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetIntersectionPoint</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">FCP_mod_r</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">Center_mod_r</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">FCP_mod_l</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">Center_mod_l</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">control_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">HalfVCs_mod_r</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">FCP_mod_r</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">center_m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                  <span class="n">FCP_mod_l</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">HalfVCs_mod_l</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                    <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">HF</span><span class="o">.</span><span class="n">BezierCustom</span><span class="p">(</span>
                            <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                            <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span>
                            <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">:]))</span>
                    <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                        <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">line_weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">patches_out</span><span class="p">,</span> <span class="n">weights_out</span><span class="p">,</span> <span class="n">line_weights_out</span>

    <span class="k">def</span> <span class="nf">_GeoPlotBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">GCurvesIn</span><span class="p">,</span> <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the geometric curve.</span>

<span class="sd">        Plots the given geometric curve</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis object</span>
<span class="sd">            The figure axis to add elements to</span>

<span class="sd">        GCurvesIn : List of curves</span>
<span class="sd">            List of Geometric Curves; data for each curve is same as used in</span>
<span class="sd">            loop initialization from curve:</span>
<span class="sd">            point_set, is_closed, end_pts_pin, wadd = curve</span>
<span class="sd">            end_pts_pin and wadd are ignored</span>

<span class="sd">        PP : PlotParameters object</span>
<span class="sd">            For this method, the relevant PlotParameters attributes are:</span>

<span class="sd">        linewidth_curve : float</span>
<span class="sd">            The line width of the geometric curve. Default is 1.0</span>

<span class="sd">        linecolor_curve : str</span>
<span class="sd">            The line color of the geometric curve. Default is &#39;b&#39; (blue).</span>

<span class="sd">        alpha_curve : float</span>
<span class="sd">            The opacity of the geometric curve.  Default is 1.0 (completely</span>
<span class="sd">            opaque/not transparent).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">GCurvesIn</span><span class="p">:</span>
            <span class="n">point_set</span><span class="p">,</span> <span class="n">is_closed</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">curve</span>
            <span class="n">gcpatches</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">is_closed</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">point_set</span><span class="p">)</span><span class="o">+</span><span class="n">wrap</span><span class="p">):</span>
                <span class="n">gcpatches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">HF</span><span class="o">.</span><span class="n">BezierLinear</span><span class="p">(</span><span class="n">point_set</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                    <span class="n">point_set</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_set</span><span class="p">)]))</span>
            <span class="n">Pcollection</span> <span class="o">=</span> <span class="n">PatchCollection</span><span class="p">(</span><span class="n">gcpatches</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
                                          <span class="n">alpha</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">alpha_curve</span><span class="p">,</span>
                                          <span class="n">capstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span>
                                          <span class="n">joinstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_curve</span><span class="p">)</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linecolor_curve</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">Pcollection</span><span class="p">)</span>

<div class="viewcode-block" id="Triangulation2D.TriCopy">
<a class="viewcode-back" href="../top_advec_bnd.html#top_advec_bnd.Triangulation2D.TriCopy">[docs]</a>
    <span class="k">def</span> <span class="nf">TriCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">EvolutionReset</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a copy of this Triangulation2D object.</span>

<span class="sd">        Custom, as a deepcopy is not sufficient.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        EvolutionReset : bool</span>
<span class="sd">            If True (default), then the WeightOperatorList is reset to</span>
<span class="sd">            be an empty list.  i.e. the memory of any past evolution</span>
<span class="sd">            is ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Triangulation2D object</span>
<span class="sd">            Returns a copy of this Triangulation2D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  create an empty triangulation object (to be returned at the end)</span>
        <span class="n">TriC</span> <span class="o">=</span> <span class="n">Triangulation2D</span><span class="p">([],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">EvolutionReset</span><span class="p">:</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">_atstep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atstep</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">_extranum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extranum</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">Domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Domain</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">_ptnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">_extrapoints</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extrapoints</span><span class="p">)</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">pointpos</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">_pointposfuture</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">)</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">_Vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Vec</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">)):</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Simplex2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="p">)</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">SLindex</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">IsBoundarySimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">IsBoundarySimp</span>
        <span class="c1">#  now create the links</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">SLindex</span><span class="p">]</span>
        <span class="c1">#  now fill the pointlist</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">pointlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">)):</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">pointlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">SLindex</span><span class="p">])</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">_totalnumedges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">EvolutionReset</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">)):</span>
                <span class="n">TriC</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">WeightOperator</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">es</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">TriC</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Spencer A. Smith.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>