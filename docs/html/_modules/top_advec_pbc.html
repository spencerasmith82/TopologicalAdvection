<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>top_advec_pbc &mdash; Topological Advection 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=8d563738"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Topological Advection
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Topological Advection</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">top_advec_pbc</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for top_advec_pbc</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module for topological advection with periodic boundaries.</span>

<span class="sd">This module contains child classes (derived from top_advec_base.py) that are</span>
<span class="sd">tailored to the case where particles move on a doubly periodic domain (torus).</span>
<span class="sd">The topological advection algorithm takes trajectories of point particles in</span>
<span class="sd">2D and determines how this motion affects the state of material curves in the</span>
<span class="sd">surrounding medium.  Curves are encoded topologically as &#39;loops&#39; with a</span>
<span class="sd">triangulation of the points acting as a basis for the loops.  As the points</span>
<span class="sd">move, the triangulation is updated, and operators which act on loops are</span>
<span class="sd">accumulated.</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">Simplex2D</span>
<span class="sd">    Class representing a triangle / 2D simplex</span>

<span class="sd">Loop</span>
<span class="sd">    Class representing a topological loop or set of loops.</span>

<span class="sd">WeightOperator</span>
<span class="sd">    Class representing an operator that acts on loops.</span>

<span class="sd">PlotParameters:</span>
<span class="sd">    Data class for grouping plot parameters</span>

<span class="sd">Triangulation2D</span>
<span class="sd">    Class representing a triangulation of data points in a 2D domain.</span>
<span class="sd">    With methods for evolving the triangulation forward due to moving points,</span>
<span class="sd">    intializing loops, evolving loops, and plotting.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">Delaunay</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">PatchCollection</span><span class="p">,</span> <span class="n">LineCollection</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">rcParams</span>
<span class="kn">from</span> <span class="nn">top_advec_base</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Simplex2D_Base</span><span class="p">,</span> <span class="n">Loop_Base</span><span class="p">,</span> <span class="n">WeightOperator_Base</span><span class="p">,</span>
                            <span class="n">Triangulation2D_Base</span><span class="p">,</span> <span class="n">PlotParameters</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">helper_fns</span> <span class="k">as</span> <span class="nn">HF</span>


<span class="c1"># Simplex2D class ########################################################</span>
<div class="viewcode-block" id="Simplex2D">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Simplex2D">[docs]</a>
<span class="k">class</span> <span class="nc">Simplex2D</span><span class="p">(</span><span class="n">Simplex2D_Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class representing a triangle / 2D simplex.</span>

<span class="sd">        (periodic boundaries version)</span>

<span class="sd">        (used in a 2D triangulation object)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    points : list of 3 ints</span>
<span class="sd">        List of the 3 vertex point IDs. These IDs will be used to get the</span>
<span class="sd">        vertex spatial locations from a master list that is a Triangulation2D</span>
<span class="sd">        attribue. Note that the order is only unique up to an even</span>
<span class="sd">        permutation. The permuation given on initialization is assumed to</span>
<span class="sd">        correspond to a set of geometric points that are given in counter</span>
<span class="sd">        clock-wise, CCW, order. Moving about this list (and other Simplex2D</span>
<span class="sd">        attributes) is done via modular arithmatic: (i+1) % 3 to move CCW about</span>
<span class="sd">        the simplex from index i, and (i+2) % 3 to move CW.</span>

<span class="sd">    simplices : list of 3 simplex objects</span>
<span class="sd">        List of the 3 simplices adjacent to this simplex. Convention: simplex</span>
<span class="sd">        at position i in this list is adjacent to this simplex at the edge</span>
<span class="sd">        across from self.points[i]</span>

<span class="sd">    edgeids : list of 3 ints</span>
<span class="sd">        List of the 3 edge ids. Each edge has an identifying integer that is</span>
<span class="sd">        used when keeping track of loop coordinates (in loop class).</span>

<span class="sd">    SLindex : int</span>
<span class="sd">        ID of this simplex in a Simplex List attribute of Triangulation2D</span>
<span class="sd">        (simplist). This is useful for going back and forth from the local</span>
<span class="sd">        view (Simplex2D object) and the global view (Triangulation2D object)</span>

<span class="sd">    relptregion : list of lists</span>
<span class="sd">        relptregion records the relative position of points.  If the edge</span>
<span class="sd">        connecting two points of this simplex crosses the torus boundary, then</span>
<span class="sd">        we record the x,y integer displacement (how many copies of the domain</span>
<span class="sd">        over in the x and y direction) of the second point from the</span>
<span class="sd">        perspective of the first (with the first and second point ordering</span>
<span class="sd">        determined by the CCW simplex ordering, and the unique edge indexed as</span>
<span class="sd">        usual - i.e. associated with the index of the point it is across from)</span>

<span class="sd">            Example: in a fundamental domain of Dx=Dy=1, consider the first</span>
<span class="sd">            point at [0.5,0.7] and second point at [0.5,0.1], where the line</span>
<span class="sd">            connecting them goes through the top boundary (remember, the</span>
<span class="sd">            periodic boundary conditions). Then the integer pair describing</span>
<span class="sd">            this edge from this triangle would be [0,1], since we have to go</span>
<span class="sd">            one copy up in the y direction to get to the second point. This</span>
<span class="sd">            extra bit of information allows us to consistently define</span>
<span class="sd">            distances between points and find triangle areas.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    LocalID(IDin)</span>
<span class="sd">        Given the ID (IDin) of a vertex/point in this triangle, this returns</span>
<span class="sd">        the local ID, i.e. the integer i = 0,1,2 s.t. self.points[i] = IDin</span>

<span class="sd">    SimpNeighbors(IDin)</span>
<span class="sd">        Given the ID (IDin) of a vertex/point in this triangle, this traverses</span>
<span class="sd">        the triangulation about this point (CCW) and returns the list of</span>
<span class="sd">        simplices that surround it in CCW order (as well as a list of local</span>
<span class="sd">        ids for IDin in each of the simplices in the list). Note that this</span>
<span class="sd">        requires that this simplex is connected up with other simplices in a</span>
<span class="sd">        triangulation.</span>

<span class="sd">    EdgeNeighbors(IDin)</span>
<span class="sd">        Find the ids of edges about a given point</span>

<span class="sd">    SimpLink(S_other, S_other_locid, edge_share)</span>
<span class="sd">        Link self with S_other simplex. To deal with cases of degenerate</span>
<span class="sd">        triangles (e.g. triangle with same point at different vertices),</span>
<span class="sd">        extra parameters are passed in (S_other_locid and edge_share).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IDlist</span><span class="p">,</span> <span class="n">RelPtPos</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the simplex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        IDlist : list of 3 ints</span>
<span class="sd">            List of the 3 point IDs from the master list (part of the</span>
<span class="sd">            tranguation class). It is assumed that IDlist already refers to</span>
<span class="sd">            points in the proper permutation (list order == ccw geometric</span>
<span class="sd">            order). Sets the points attribute.</span>

<span class="sd">        RelPtPos : list of lists</span>
<span class="sd">            Sets relptregion, which records the relative position of points.</span>
<span class="sd">            If the edge connecting two points of this simplex crosses the</span>
<span class="sd">            torus boundary, then we record the x,y integer displacement</span>
<span class="sd">            (how many copies of the domain over in the x and y direction)</span>
<span class="sd">            of the second point from the perspective of the first (with the</span>
<span class="sd">            first and second point ordering determined by the CCW simplex</span>
<span class="sd">            ordering, and the unique edge indexed as usual - i.e. associated</span>
<span class="sd">            with the index of the point it is across from)</span>

<span class="sd">            Example: in a fundamental domain of Dx=Dy=1, consider the first</span>
<span class="sd">            point at [0.5,0.7] and second point at [0.5,0.1], where the line</span>
<span class="sd">            connecting them goes through the top boundary (remember, the</span>
<span class="sd">            periodic boundary conditions). Then the integer pair describing</span>
<span class="sd">            this edge from this triangle would be [0,1], since we have to go</span>
<span class="sd">            one copy up in the y direction to get to the second point. This</span>
<span class="sd">            extra bit of information allows us to consistently define</span>
<span class="sd">            distances between points and find triangle areas.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Other attributes are set when linking them up in a Triangulation2D</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">IDlist</span><span class="p">)</span>
        <span class="c1"># the relative points regions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relptregion</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">RelPtPos</span><span class="p">)</span>

    <span class="c1"># More complex than sibling class version (bnd), as it compares both edges</span>
    <span class="c1"># and simplicesfor a halting criteria in traversing the simplices about a</span>
    <span class="c1"># point. This allows for edge cases of degenerate triangulations, where</span>
    <span class="c1"># some edges have boundary points that are the same point.</span>
<div class="viewcode-block" id="Simplex2D.SimpNeighbors">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Simplex2D.SimpNeighbors">[docs]</a>
    <span class="k">def</span> <span class="nf">SimpNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IDin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the set simpices which share a point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        IDin : int</span>
<span class="sd">            The ID of a vertex/point in this simplex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of Simplex2D objects</span>
<span class="sd">            The simplices (in CCW cyclical order about the shared point -</span>
<span class="sd">            IDin) adjacent to a point (IDin).</span>

<span class="sd">        list of ints</span>
<span class="sd">            The local ids of IDin in each simplex in the returned simplex list</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method requires that the simplex is part of a Triangulation2D</span>
<span class="sd">        object (so that it has neighboring simplices). The LocalIDList is</span>
<span class="sd">        required for use cases where the NeighborList contains a simplex twice</span>
<span class="sd">        (and therefore the simplex contains IDin twice, and we can&#39;t just use</span>
<span class="sd">        LocalID method)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">NeighborList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">LocalIDList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">IDin</span><span class="p">)</span>
        <span class="n">NeighborList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">LocalIDList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stpt</span><span class="p">)</span>
        <span class="n">sharededge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">stpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">start_sharededge</span> <span class="o">=</span> <span class="n">sharededge</span>
        <span class="n">lsimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">stpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">lsimplid</span> <span class="o">=</span> <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sharededge</span><span class="p">)</span>
        <span class="n">NeighborList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsimp</span><span class="p">)</span>
        <span class="n">LocalIDList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lsimplid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">sharededge</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">lsimplid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">lsimp</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">lsimplid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">lsimplid</span> <span class="o">=</span> <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sharededge</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="n">lsimp</span> <span class="ow">is</span> <span class="n">NeighborList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                   <span class="ow">and</span> <span class="n">NeighborList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">NeighborList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                   <span class="ow">and</span> <span class="n">start_sharededge</span> <span class="o">==</span> <span class="n">sharededge</span><span class="p">):</span>
            <span class="n">NeighborList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsimp</span><span class="p">)</span>
            <span class="n">LocalIDList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lsimplid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">sharededge</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">lsimplid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">lsimp</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">lsimplid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">lsimplid</span> <span class="o">=</span> <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sharededge</span><span class="p">)</span>
        <span class="c1"># exclude the last element</span>
        <span class="k">return</span> <span class="n">NeighborList</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">LocalIDList</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="Simplex2D.EdgeNeighbors">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Simplex2D.EdgeNeighbors">[docs]</a>
    <span class="k">def</span> <span class="nf">EdgeNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IDin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the edges which share a point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        IDin : int</span>
<span class="sd">            The ID of a vertex/point in this simplex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of</span>
<span class="sd">            The edge ids (in CCW cyclical order about the shared point -</span>
<span class="sd">            IDin) adjacent to a point (IDin).</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method requires that the simplex is part of a Triangulation2D</span>
<span class="sd">        object (so that it has neighboring simplices).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">NeighborList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">EdgeList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">IDin</span><span class="p">)</span>
        <span class="n">NeighborList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">sharededge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">stpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">EdgeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sharededge</span><span class="p">)</span>
        <span class="n">start_sharededge</span> <span class="o">=</span> <span class="n">sharededge</span>
        <span class="n">lsimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">stpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">lsimplid</span> <span class="o">=</span> <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sharededge</span><span class="p">)</span>
        <span class="n">NeighborList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsimp</span><span class="p">)</span>
        <span class="n">sharededge</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">lsimplid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">EdgeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sharededge</span><span class="p">)</span>
        <span class="n">lsimp</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">lsimplid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">lsimplid</span> <span class="o">=</span> <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sharededge</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="n">lsimp</span> <span class="ow">is</span> <span class="n">NeighborList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                   <span class="ow">and</span> <span class="n">NeighborList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">NeighborList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                   <span class="ow">and</span> <span class="n">start_sharededge</span> <span class="o">==</span> <span class="n">sharededge</span><span class="p">):</span>
            <span class="n">NeighborList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lsimp</span><span class="p">)</span>
            <span class="n">sharededge</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">lsimplid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">EdgeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sharededge</span><span class="p">)</span>
            <span class="n">lsimp</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">lsimplid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">lsimplid</span> <span class="o">=</span> <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sharededge</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EdgeList</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># exclude the last element</span></div>


<div class="viewcode-block" id="Simplex2D.SimpLink">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Simplex2D.SimpLink">[docs]</a>
    <span class="k">def</span> <span class="nf">SimpLink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S_other</span><span class="p">,</span> <span class="n">S_other_locid</span><span class="p">,</span> <span class="n">edge_share</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Links this simplex with S_other (and vice versa).</span>

<span class="sd">        Used during an edge flip operation to ensure the newly created</span>
<span class="sd">        simplices are integrated into the triangulation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        S_other : Simplex2D object</span>
<span class="sd">            The simplex to link with self</span>

<span class="sd">        S_other_locid : int</span>
<span class="sd">            The local index of the shared edge in S_other</span>

<span class="sd">        edge_share : int</span>
<span class="sd">            The index of the shared edge between self and S_other</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This version uses the extra information (new simplex local id, shared</span>
<span class="sd">        edge id) to avoid referencing the points (on the torus, cases exist</span>
<span class="sd">        where two adjacent simplices share all three points)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_locid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge_share</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">edge_locid</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_other</span>
        <span class="n">S_other</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">S_other_locid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span></div>
</div>

<span class="c1"># End of Simplex2D_PBC class #################################################</span>


<span class="c1"># Loop Class #################################################################</span>
<div class="viewcode-block" id="Loop">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Loop">[docs]</a>
<span class="k">class</span> <span class="nc">Loop</span><span class="p">(</span><span class="n">Loop_Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class representing a topological loop or set of loops.</span>

<span class="sd">    The coordinate system (basis) for this representation is fixed by a</span>
<span class="sd">    particular Triangulation2D object.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    weightlist : list of ints/real numbers</span>
<span class="sd">        List of intersection coordinates for the loop.  Each location in the</span>
<span class="sd">        list corresponds to an edge in the Triangulation2D object (list index</span>
<span class="sd">        is edge id), and the list value at this index is the number of</span>
<span class="sd">        transverse intersections of our geometric loop (pulled &#39;tight&#39; for</span>
<span class="sd">        minimal intersection number) with the associated triangulation edge.</span>
<span class="sd">        A list of shear coordinates is also possible.</span>

<span class="sd">    Shear : bool</span>
<span class="sd">        Flag to denote the type of representation: False for regular</span>
<span class="sd">        intersection coordinates, and True for shear coordinates.  Shear</span>
<span class="sd">        coordinates allow us to create a &#39;mesh&#39; of bands along each edge,</span>
<span class="sd">        which is helpful for topological entropy calculations</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    GetWeightTotal()</span>
<span class="sd">        Returns the sum of the intersection coordinates (weights), which is a</span>
<span class="sd">        good proxy for the length of the loop.</span>

<span class="sd">    ProjectivizeWeights()</span>
<span class="sd">        Divides all the weights by the max weight value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tri</span><span class="p">,</span> <span class="n">rbands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">curves</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Shear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize Loop.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tri : Triangulation2D object (really child class of Triangulation2D)</span>
<span class="sd">            tri is used as a basis with which the input curve options (rbands,</span>
<span class="sd">            curves, and mesh) are turned into intersection coordinates.</span>
<span class="sd">            Several tri methods are used to initialize weightlist.</span>

<span class="sd">        rbands : list of lists (of ints)</span>
<span class="sd">            rbands is a collection (outer list) of bands (inner lists). Each</span>
<span class="sd">            band is a list of point ids.  This list represents a CCW oriented</span>
<span class="sd">            loop in of the points in tri, with the loop going around a point</span>
<span class="sd">            on the side that makes a &#39;large&#39; (&gt;pi) angle with the lines</span>
<span class="sd">            connecting this point to the 2 adjacent points in the band.  Bands</span>
<span class="sd">            equvalent up to cyclic shifts of the points in the list. This is</span>
<span class="sd">            often used with just two point ids to create a band the goes from</span>
<span class="sd">            one point to another.</span>

<span class="sd">        curves : list of lists</span>
<span class="sd">            curves is a collection (outer list) of curves (inner lists). Each</span>
<span class="sd">            curve is a list with four elements: The first is a list of point</span>
<span class="sd">            positions (each point position is a list: [x,y]), which define a</span>
<span class="sd">            sequence of lines connected end to end. The second is a boolean</span>
<span class="sd">            (is_closed) which if signals that the point position list should</span>
<span class="sd">            wrap-around (True), or be considered a curve with end- points</span>
<span class="sd">            (False). The third is a pair (list) of 2 booleans which determine</span>
<span class="sd">            if we put a cap (circle around the closest point) around end 1 and</span>
<span class="sd">            end 2 of the curve. This is only relevant if the loop is not</span>
<span class="sd">            closed.  The final element is a number (wadd, can be int or float)</span>
<span class="sd">            that is the weight we add to crossed edges.</span>

<span class="sd">        Shear : bool</span>
<span class="sd">            Flag to denote the type of representation: False for regular</span>
<span class="sd">            intersection coordinates, and True for shear coordinates.</span>

<span class="sd">        mesh : bool</span>
<span class="sd">            If True, rbands and curves will be ignored, and the loop will be</span>
<span class="sd">            initialized in the &#39;mesh&#39; configuration, where each edge has a</span>
<span class="sd">            segment of the loop connecting adjacent points. Also sets</span>
<span class="sd">            Shear = True if True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            rbands is already a topological specification of a loop (points in</span>
<span class="sd">            tri), while curves are a geometric specification of a loop.</span>
<span class="sd">            Generally, avoid loops which trasversely intersect each other, as</span>
<span class="sd">            the way the &#39;X&#39; is reconnected is dependent on the local details</span>
<span class="sd">            of the triangulation.  However, intersections will still result</span>
<span class="sd">            in valid loop coordinates.</span>
<span class="sd">            Mesh is useful for picking up mixing thoughout the entire domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tri</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Shear</span> <span class="o">=</span> <span class="n">Shear</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                <span class="c1"># represents bands pinned to adjacent</span>
                <span class="c1"># points in this triangulation.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Shear</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># mesh must be evaluated with shear coordinates</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Shear</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rbands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tri</span><span class="o">.</span><span class="n">_BandWeightInitialize</span><span class="p">(</span><span class="n">rbands</span><span class="p">,</span> <span class="n">LoopIn</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">curves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tri</span><span class="o">.</span><span class="n">_CurveWeightInitialize</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">LoopIn</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">RegLoop</span> <span class="o">=</span> <span class="n">Loop</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rbands</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tri</span><span class="o">.</span><span class="n">_BandWeightInitialize</span><span class="p">(</span><span class="n">rbands</span><span class="p">,</span> <span class="n">LoopIn</span><span class="o">=</span><span class="n">RegLoop</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">curves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tri</span><span class="o">.</span><span class="n">_CurveWeightInitialize</span><span class="p">(</span><span class="n">curves</span><span class="p">,</span> <span class="n">LoopIn</span><span class="o">=</span><span class="n">RegLoop</span><span class="p">)</span>
                <span class="c1">#  This first creates a regular loop (regular coordinates),</span>
                <span class="c1">#  then feeds this into the triangulation object to get the</span>
                <span class="c1">#  shear coordinates</span>
                <span class="n">tri</span><span class="o">.</span><span class="n">_ShearWeightInitialize</span><span class="p">(</span><span class="n">RegLoop</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Loop.GetWeightTotal">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Loop.GetWeightTotal">[docs]</a>
    <span class="k">def</span> <span class="nf">GetWeightTotal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">Shear</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">WT</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">)):</span>
                <span class="n">WT</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">WT</span></div>


<div class="viewcode-block" id="Loop.ProjectivizeWeights">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Loop.ProjectivizeWeights">[docs]</a>
    <span class="k">def</span> <span class="nf">ProjectivizeWeights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mwv</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">/</span><span class="n">mwv</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weightlist</span><span class="p">]</span></div>


<div class="viewcode-block" id="Loop.LoopCopy">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Loop.LoopCopy">[docs]</a>
    <span class="k">def</span> <span class="nf">LoopCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>
</div>

<span class="c1"># End of Loop Class ##########################################################</span>


<span class="c1"># WeightOperator Class #######################################################</span>
<div class="viewcode-block" id="WeightOperator">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.WeightOperator">[docs]</a>
<span class="k">class</span> <span class="nc">WeightOperator</span><span class="p">(</span><span class="n">WeightOperator_Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class representing an operator that acts on loops.</span>

<span class="sd">        It is generated every time a triangulation flip occurs during the</span>
<span class="sd">        evolution of a triangulation object, and holds the information needed</span>
<span class="sd">        to update the weightlist of a loop.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    eids : list of 5 ints</span>
<span class="sd">        The edge ids of the 5 elements in a loop weightlist whose</span>
<span class="sd">        corresponding triangulation edges surround a triangulation flip.</span>
<span class="sd">        For the quadrilateral whose diagonal edge will be flipped, the order</span>
<span class="sd">        of the edge ids in eids is: central diagonal first, then CCW perimeter</span>
<span class="sd">        edges, starting with an edge that, along with its quadrilateral</span>
<span class="sd">        opposite, form a &quot;Z&quot; with the central diagonal edge.</span>

<span class="sd">    time : real number</span>
<span class="sd">        the global time at which the flip happens</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    Update(LoopIn, Reverse = False)</span>
<span class="sd">        Updates the weightlist attribute of LoopIn</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IndexSet</span><span class="p">,</span> <span class="n">TimeIn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize WeightOperator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        IndexSet : list of (5) ints</span>
<span class="sd">            IndexSet contains the edge ids needed for updating a loop</span>
<span class="sd">            weightlist during a triangulation flip.</span>

<span class="sd">        TimeIn : real number</span>
<span class="sd">            the global time at which the flip happens</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eids</span> <span class="o">=</span> <span class="n">IndexSet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">TimeIn</span>

<div class="viewcode-block" id="WeightOperator.Update">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.WeightOperator.Update">[docs]</a>
    <span class="k">def</span> <span class="nf">Update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">Reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the weightlist attribute of LoopIn.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        LoopIn : Loop Object</span>
<span class="sd">            This is the loop whose weightlist will be updated (in place).</span>

<span class="sd">        Reverse : bool</span>
<span class="sd">            Reverse = True is used to evolve loops backwards in time.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">WL</span> <span class="o">=</span> <span class="p">[</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">LoopIn</span><span class="o">.</span><span class="n">Shear</span><span class="p">:</span>
            <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">WL</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">WL</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                                   <span class="n">WL</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">WL</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">-</span> <span class="n">WL</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># The main equation for updating intersection coordinates</span>
            <span class="c1"># Note that it workds equally well forward/backward in time</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For Shear weights, the surrounding quadrilateral weights</span>
            <span class="c1"># are also modified</span>
            <span class="n">Diag</span> <span class="o">=</span> <span class="n">WL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Diag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Diag</span>
                <span class="k">if</span> <span class="n">Diag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Reverse</span><span class="p">:</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Reverse</span><span class="p">:</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eids</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">Diag</span></div>
</div>

<span class="c1"># End of WeightOperator Class ################################################</span>


<span class="c1"># PlotParameters Class ######################################################</span>
<div class="viewcode-block" id="PlotParameters">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.PlotParameters">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PlotParameters</span><span class="p">(</span><span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parameters for plotting.</span>

<span class="sd">    Class containing all of the parameters used in printing the</span>
<span class="sd">    triangulation and loops, and their default values.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        The filename (including local path) to save the figure as.</span>
<span class="sd">        If None (default), then then the figure is printed to screen.</span>

<span class="sd">    triplot : bool</span>
<span class="sd">        Flag - prints the background triangulation if True (default) and</span>
<span class="sd">        excludes it if False.</span>

<span class="sd">    Delaunay : bool</span>
<span class="sd">        Flag - if True then uses Voronoi-based control points to draw the</span>
<span class="sd">        train-track representation of the loops.  If False (default), then</span>
<span class="sd">        triangle centers are used as control points.</span>

<span class="sd">    DelaunayAdd : bool</span>
<span class="sd">        Flag - A different Voronoi-based control point plotting system for</span>
<span class="sd">        the train-tracks.  This represents the train-track weights as line</span>
<span class="sd">        widths, which join naturally at train-track switch locations. This</span>
<span class="sd">        is only relevant if Delaunay is True.</span>

<span class="sd">    Bounds : list of lists</span>
<span class="sd">        Bounds has the format [[x_min, y_min],[x_max, y_max]], and determines</span>
<span class="sd">        the bounding box for plotting.  This is usually set automatically.</span>

<span class="sd">    FigureSizeX : float</span>
<span class="sd">        The width of the image in inches.  The height is automatically</span>
<span class="sd">        calculated based on Bounds.</span>

<span class="sd">    dpi : int</span>
<span class="sd">        The dots per inch.  Increase to increase the resolution and size of</span>
<span class="sd">        resulting image file.</span>

<span class="sd">    ptlabels : bool</span>
<span class="sd">        If True, the integer label for each point is plotted next to the</span>
<span class="sd">        point. False is default.  Mainly used for visually finding groups of</span>
<span class="sd">        points to encircle with a band.</span>

<span class="sd">    markersize : float</span>
<span class="sd">        Sets the markersize of the points.</span>

<span class="sd">    linewidth_tri : float</span>
<span class="sd">        The line width of the background triangulation.</span>

<span class="sd">    linecolor_tri : str</span>
<span class="sd">        The color of the triangulation lines. Default is &#39;g&#39; (green).</span>

<span class="sd">    color_weights : bool</span>
<span class="sd">        If True, then the individual segments of the train-track will be</span>
<span class="sd">        colored based on their weights.  This is one way to encode weight</span>
<span class="sd">        information in the plots.  Default is False.</span>

<span class="sd">    log_color : bool</span>
<span class="sd">        If True these colors will be assigned using the log of the weights. If</span>
<span class="sd">        False (default), the weights them-selves will determine the color</span>
<span class="sd">        scale</span>

<span class="sd">    color_map : str</span>
<span class="sd">        The color map to be used, default is &#39;inferno_r&#39;.</span>

<span class="sd">    linewidth_tt : float</span>
<span class="sd">        The line width of the train-track.  If DelaunayAdd is True, then this</span>
<span class="sd">        is the maximum line-width</span>

<span class="sd">    linecolor_tt : str</span>
<span class="sd">        The line color of the train-track. Default is &#39;r&#39; (red).</span>

<span class="sd">    alpha_tt : float</span>
<span class="sd">        The opacity of the train-track.  Default is 1.0 (completely</span>
<span class="sd">        opaque/not transparent).</span>

<span class="sd">    frac : float</span>
<span class="sd">        For plotting with the Delaunay flag, this determined how curved the</span>
<span class="sd">        train-tracks appear.  A value of 1.0 is maximally curvy (no linear</span>
<span class="sd">        segments), while a value of 0.0 would be just straight lines on</span>
<span class="sd">        following the Voronoi skeleton.  Default is 0.9</span>

<span class="sd">    tt_lw_min_frac : float</span>
<span class="sd">        The minimum fraction of linewidth_tt that will be represented.  This</span>
<span class="sd">        means that all train-track segments with weights below this fraction</span>
<span class="sd">        of the maximum weight will be represented as this fraction of</span>
<span class="sd">        linewidth_tt.  All segments with larger weight will have a line width</span>
<span class="sd">        that linear in this range.</span>

<span class="sd">    linewidth_curve : float</span>
<span class="sd">        The line width of the geometric curve. Default is 1.0</span>

<span class="sd">    linecolor_curve : str</span>
<span class="sd">        The line color of the geometric curve. Default is &#39;b&#39; (blue).</span>

<span class="sd">    alpha_curve : float</span>
<span class="sd">        The opacity of the geometric curve.  Default is 1.0 (completely</span>
<span class="sd">        opaque/not transparent).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># main flags/choices</span>
    <span class="n">Delaunay</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">DelaunayAdd</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># initial setup</span>
    <span class="n">Bounds</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">FigureSizeX</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">dpi</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span>
    <span class="n">ptlabels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">markersize</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="n">linewidth_tri</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">linecolor_tri</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;g&#39;</span>
    <span class="n">color_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">log_color</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">color_map</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;inferno_r&#39;</span>
    <span class="c1"># train track specifications</span>
    <span class="n">linewidth_tt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">linecolor_tt</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
    <span class="n">alpha_tt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="c1"># Delaunay</span>
    <span class="n">frac</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span>
    <span class="c1"># DelaunayAdd</span>
    <span class="n">tt_lw_min_frac</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="n">_conversion_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># internal only</span>
    <span class="n">_max_weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># internal only</span>
    <span class="n">linewidth_curve</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">linecolor_curve</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
    <span class="n">alpha_curve</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span></div>

<span class="c1"># End of PlotParameters Class ################################################</span>


<span class="c1"># Triangulation2D Class ######################################################</span>
<div class="viewcode-block" id="Triangulation2D">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Triangulation2D">[docs]</a>
<span class="k">class</span> <span class="nc">Triangulation2D</span><span class="p">(</span><span class="n">Triangulation2D_Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The central class in the overal Topological Advection algorithm.</span>

<span class="sd">    This class represents a triangulation of data points in a 2D domain.</span>
<span class="sd">    It has methods for evolving the triangulation due to the motion of data</span>
<span class="sd">    points, acting as a basis for encoding loops, accumulating weight</span>
<span class="sd">    operators, and plotting.  This child of the parent Triangulation2D_Base</span>
<span class="sd">    class works for doubly periodic boundary conditions (i.e. Torus).</span>

<span class="sd">    Note: Only the main attribues and methods are listed here.</span>
<span class="sd">    Note: The triangulation is initialized as a Delaunay triangulation.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pointlist : list</span>
<span class="sd">        A list of simplex objects.  Object at index i has the point with</span>
<span class="sd">        point id i in its point list.  Allows for O(1) lookup of points in the</span>
<span class="sd">        triangulation.  Note, not every simplex is in this list.</span>

<span class="sd">    FDsizes : list</span>
<span class="sd">        A list that sets the fundamental domain of the torus.  FDsize =</span>
<span class="sd">        [x_width, y_height].  By convention x_min, y_min = 0, and</span>
<span class="sd">        x_max, y_max = FDsizes.  FDsizes are used for the moduluar</span>
<span class="sd">        arithmatic that enforces the periodic boundaries.</span>

<span class="sd">    pointpos : list</span>
<span class="sd">        A list of the [x,y] positions for the points at the current time</span>
<span class="sd">        Note that all points must be within the fundamental domain.</span>

<span class="sd">    pointposfuture : list</span>
<span class="sd">        List of the [x,y] positions at the next time step.  Used with the</span>
<span class="sd">        Evolution method.</span>

<span class="sd">    simplist : list</span>
<span class="sd">        List of all of the simplices that make up the triangulation.</span>
<span class="sd">        Individual simplices have an id (SLindex) that indicates their</span>
<span class="sd">        location in this list.</span>

<span class="sd">    WeightOperatorList : list</span>
<span class="sd">        List of WeightOperator objects.  As the triangulation is evolved</span>
<span class="sd">        forward due to point motions, retriangulations with edge flips are</span>
<span class="sd">        needed.  For each flip, we record the data needed to evolve a loop</span>
<span class="sd">        forward.  This list is ordered (increasing) in time.</span>


<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    Evolve(ptlist, Maintain_Delaunay = False)</span>
<span class="sd">        This evolves the triangulation forward due to the motion of the points</span>
<span class="sd">        - new point positions in ptlist. Options for evolution via collapse</span>
<span class="sd">        events or to maintain a Delaunay triangulation.  For every edge flip</span>
<span class="sd">        needed, a WeightOperator is added to the WeightOperator list.</span>

<span class="sd">    OperatorAction(LoopIn, index = None, Reverse = False, option = 3)</span>
<span class="sd">        This evolves forward an individual loop object (i.e. updates its</span>
<span class="sd">        weightlist due to the action of the WeightOperators in</span>
<span class="sd">        WeightOperatorList).</span>

<span class="sd">    Plot(LoopIn=None, GCurvesIn=None, PP: PlotParameters=PlotParameters())</span>
<span class="sd">        This plots the triangulation and loop.  See PlotParameters data class</span>
<span class="sd">        documentation for details on the many options.</span>

<span class="sd">    TriCopy(EvolutionReset = True)</span>
<span class="sd">        This returns a copy of this Triangulation2D object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptlist</span><span class="p">,</span> <span class="n">Domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Triangulation Initialization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ptlist : list</span>
<span class="sd">            ptlist is the list of [x,y] positions for the points at the</span>
<span class="sd">            initial time.</span>

<span class="sd">        Domain : list</span>
<span class="sd">            Domain = [[x_min,y_min],[x_max,y_max]].  Both x_min and y_min</span>
<span class="sd">            are equal to zero by convention, and we will save just the</span>
<span class="sd">            width and height in FDsizes.  If Domain is None (default, but</span>
<span class="sd">            it is highly recommended to pass in a Domain), then the FDsizes</span>
<span class="sd">            will be determined from max x/y pt values.</span>

<span class="sd">        empty : bool</span>
<span class="sd">            Used for creating an empty object, which is then used for object</span>
<span class="sd">            copying.  Default is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">Domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Domain must be of the form [[0,0],&quot;</span>
                          <span class="s2">&quot; [x_width, y_height]]&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the Domain from point positions, &quot;</span>
                          <span class="s2">&quot;(not ideal!)&quot;</span><span class="p">)</span>
                    <span class="n">Domain_approx</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetBoundingDomainSlice</span><span class="p">(</span><span class="n">ptlist</span><span class="p">,</span> <span class="n">frac</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span> <span class="o">=</span> <span class="n">Domain_approx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span> <span class="o">=</span> <span class="n">Domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># [Dx, Dy]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating the Domain from point positions, &quot;</span>
                      <span class="s2">&quot;(not ideal!)&quot;</span><span class="p">)</span>
                <span class="n">Domain_approx</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetBoundingDomainSlice</span><span class="p">(</span><span class="n">ptlist</span><span class="p">,</span> <span class="n">frac</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span> <span class="o">=</span> <span class="n">Domain_approx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                           <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptlist</span><span class="p">)</span>
        <span class="c1">#  These are two lists that give the relative copy of the FD that the</span>
        <span class="c1">#  final position is in relative to the initial position (initial pos</span>
        <span class="c1">#  is thought of as being in the FD). The first one is relative to the</span>
        <span class="c1">#  initial positions and does not change in a given time-step (though</span>
        <span class="c1">#  of course is re-filled at the beginning of each time-step).  The</span>
        <span class="c1">#  second one starts off as identical, but is updated as points cross</span>
        <span class="c1">#  the boundary of the FD. To be more specific, as a point crosses the</span>
        <span class="c1">#  FD, we still think of it as being in the FD, but the copy of the FD</span>
        <span class="c1">#  that the final position is in (relative to this now-moved point</span>
        <span class="c1">#  position) is now different.  The Crossing event list events will</span>
        <span class="c1">#  update this list.</span>
        <span class="c1">#  FuturePosRelCopyLoc holds the indices that need to be put into</span>
        <span class="c1">#  dpindices to get the shifts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># UpdatedFuturePosRelCopyLoc directly holds the shifts (updated),</span>
        <span class="c1"># - this makes it easier to update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_UpdatedFuturePosRelCopyLoc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ptlist</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_LoadPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptlist</span><span class="p">):</span>
        <span class="c1">#  enforce the fundamental domain boundaries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span> <span class="o">=</span> <span class="p">[[</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
                         <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ptlist</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_SetInitialTriangulation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#  Now we add on the 8 copies of the points in the fundamental domain,</span>
        <span class="c1">#  displaced to the surrounding rectangles.  The convention will be</span>
        <span class="c1">#  that we start with the FD, then the copy down and to the left of</span>
        <span class="c1">#  the fundamental domain, and work our way around the fundamental</span>
        <span class="c1">#  domain counter clock-wise.</span>
        <span class="n">temppoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span>
        <span class="n">temppoints2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">)):</span>
            <span class="n">temppoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">temppoints</span><span class="p">,</span> <span class="n">temppoints2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">#  now we have 9x the number of actual points</span>
        <span class="c1">#  (+ the 8 neighboring copies)</span>
        <span class="c1">#  slight shear to break degeneracy in consistent</span>
        <span class="c1">#  way in the case of one point</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shear_val</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
                    <span class="n">temppoints</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">shear_val</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]:</span>
                    <span class="n">temppoints</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">shear_val</span>
        <span class="c1">#  create the initial Delaunay triangulation.  The option forces the</span>
        <span class="c1">#  creation of simplices for degenerate points by applying a random</span>
        <span class="c1">#  perturbation. (QJ for perturbations)</span>
        <span class="n">temptri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">temppoints</span><span class="p">,</span> <span class="n">qhull_options</span><span class="o">=</span><span class="s2">&quot;QJ Pp&quot;</span><span class="p">)</span>
        <span class="c1">#  the point in the FD that each point in a triangle maps to</span>
        <span class="n">ptfdID</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edgesimps</span><span class="p">,</span> <span class="n">FDsimps</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tempptlist</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">fdID</span><span class="p">,</span> <span class="n">copypos</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">fdID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tempptlist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">)</span>
                <span class="n">copypos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tempptlist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">)</span>
            <span class="n">ptfdID</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fdID</span><span class="p">)</span>
            <span class="n">InFD</span> <span class="o">=</span> <span class="p">[</span><span class="n">copypos</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">InFD</span><span class="p">):</span>  <span class="c1"># all points are in the FD</span>
                <span class="n">FDsimps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">InFD</span><span class="p">):</span>  <span class="c1"># one or two points in the FD</span>
                <span class="n">edgesimps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># else:  # no points in the FD</span>
            <span class="c1">#     # need to check for triangles that cross and edge but don&#39;t</span>
            <span class="c1">#     # have a point in the FD</span>
            <span class="c1">#     if not (copypos[0] == copypos[1] and copypos[1] == copypos[2]):</span>
            <span class="c1">#         tri_temp = [temppoints[ptid] for ptid in tempptlist]</span>
            <span class="c1">#         domain_temp = [[0, 0], self.FDsizes]</span>
            <span class="c1">#         if HF.TriEdgeCrossBnd(tri_temp, domain_temp):</span>
            <span class="c1">#             edgesimps.append(i)</span>

        <span class="c1">#  now we need to create a list of equivalent shifted triangles</span>
        <span class="c1">#  (only ones that straddle the FD edge are needed)</span>
        <span class="n">Equiv_Tri</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edgesimps</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">ptidsi</span> <span class="o">=</span> <span class="n">ptfdID</span><span class="p">[</span><span class="n">edgesimps</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgesimps</span><span class="p">)):</span>
                <span class="n">ptidsj</span> <span class="o">=</span> <span class="n">ptfdID</span><span class="p">[</span><span class="n">edgesimps</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ptidsi</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">ptidsj</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)):</span>
                        <span class="c1">#  if true, then the i and j triangles map to the same</span>
                        <span class="c1">#  points in the FD and they are the same triangle</span>
                        <span class="n">Equiv_Tri</span><span class="p">[</span><span class="n">edgesimps</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edgesimps</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">k</span><span class="p">])</span>
                        <span class="n">Equiv_Tri</span><span class="p">[</span><span class="n">edgesimps</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">edgesimps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
                        <span class="k">break</span>
        <span class="c1">#  Now we create the simplices.  Include all simplices with all pts</span>
        <span class="c1">#  in the FD, for ones with one or two pts in the FD, choose the first</span>
        <span class="c1">#  one encountered among the equiv. copies.  for each equiv copy not</span>
        <span class="c1">#  chosen (and a border simplex) create the shift that takes the</span>
        <span class="c1">#  internal id to the chosen copy&#39;s internal id (0,1,2)</span>
        <span class="n">BigToLittleList</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">LittleToBigList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">RelShift</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">FDsimps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Simplex2D</span><span class="p">((</span><span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
            <span class="n">LittleToBigList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">BigToLittleList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">RelShift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edgesimps</span><span class="p">:</span>
            <span class="c1"># haven&#39;t delt with this set, use this one at the canonical copy</span>
            <span class="k">if</span> <span class="n">RelShift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">RelShift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Simplex2D</span><span class="p">((</span><span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
                <span class="n">LittleToBigList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">BigToLittleList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
                <span class="c1"># now deal with the copies</span>
                <span class="k">for</span> <span class="n">copyid</span> <span class="ow">in</span> <span class="n">Equiv_Tri</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">RelShift</span><span class="p">[</span><span class="n">copyid</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">copyid</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">BigToLittleList</span><span class="p">[</span><span class="n">copyid</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="c1">#  so, say we look at triangle 17.  RelShift[17] gives me two items:</span>
        <span class="c1">#  RelShift[17][0] is the triangle id that corresponds to the</span>
        <span class="c1">#  cannonical triangle among the set of equivalent (via translation)</span>
        <span class="c1">#  FD boundary triangles. here: 11 of {11,17,37}.  RelShift[17][1] is</span>
        <span class="c1">#  the shift needed to go between the two triangles.  more</span>
        <span class="c1">#  specifically, the internal id of RelShift[17][1] for triangle 11</span>
        <span class="c1">#  corresponds to the internal id of 0 for triangle 17.</span>

        <span class="c1">#  Now we go through each point in the FD.  For each point we loop</span>
        <span class="c1">#  around the simplices that share this point. We link adjacent pairs</span>
        <span class="c1">#  of simplices, add in the relptpos (of the two pts across from this</span>
        <span class="c1">#  pt in the simp), add in the edge id, populate the pointlist, and</span>
        <span class="c1">#  add in the SLindex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">)]</span>
        <span class="n">edgecounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">):</span>
            <span class="n">start_simp_id_big</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">vertex_to_simplex</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
            <span class="n">start_simp_pt_loc_id_big</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span>
                <span class="n">start_simp_id_big</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
            <span class="n">start_simp_pt_loc_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">RelShift</span><span class="p">[</span><span class="n">start_simp_id_big</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                    <span class="o">+</span> <span class="n">start_simp_pt_loc_id_big</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
            <span class="n">start_simp_id</span> <span class="o">=</span> <span class="n">BigToLittleList</span><span class="p">[</span><span class="n">start_simp_id_big</span><span class="p">]</span>
            <span class="n">start_simp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">start_simp_id</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_simp</span>  <span class="c1"># populating the pointlist</span>
            <span class="c1">#  set up the relptregion</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">start_simp_id_big</span><span class="p">][</span>
                <span class="p">(</span><span class="n">start_simp_pt_loc_id_big</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">ptl</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">start_simp_id_big</span><span class="p">][</span>
                <span class="p">(</span><span class="n">start_simp_pt_loc_id_big</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">rpl</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="n">ptl</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">])</span>
                   <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="n">ptr</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">]))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">start_simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">start_simp_pt_loc_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpl</span>
            <span class="n">start_simp</span><span class="o">.</span><span class="n">SLindex</span> <span class="o">=</span> <span class="n">start_simp_id</span>
            <span class="n">this_simp_id_big</span> <span class="o">=</span> <span class="n">start_simp_id_big</span>
            <span class="n">this_simp_pt_loc_id_big</span> <span class="o">=</span> <span class="n">start_simp_pt_loc_id_big</span>
            <span class="n">this_simp_pt_loc_id</span> <span class="o">=</span> <span class="n">start_simp_pt_loc_id</span>
            <span class="n">this_simp</span> <span class="o">=</span> <span class="n">start_simp</span>
            <span class="n">next_simp_id_big</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="n">this_simp_id_big</span><span class="p">][</span>
                <span class="p">(</span><span class="n">this_simp_pt_loc_id_big</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">next_simp_pt_loc_id_big</span> <span class="o">=</span> <span class="p">(</span><span class="n">temptri</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span>
                <span class="n">next_simp_id_big</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">this_simp_id_big</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
            <span class="n">next_simp_pt_loc_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">RelShift</span><span class="p">[</span><span class="n">next_simp_id_big</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                   <span class="o">+</span> <span class="n">next_simp_pt_loc_id_big</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
            <span class="n">next_simp_id</span> <span class="o">=</span> <span class="n">BigToLittleList</span><span class="p">[</span><span class="n">next_simp_id_big</span><span class="p">]</span>
            <span class="n">next_simp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">next_simp_id</span><span class="p">]</span>
            <span class="c1">#  linking the two simplices and adding in the edge id</span>
            <span class="n">this_simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">this_simp_pt_loc_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_simp</span>
            <span class="n">next_simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">next_simp_pt_loc_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_simp</span>
            <span class="k">if</span> <span class="n">this_simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">this_simp_pt_loc_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">this_simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">this_simp_pt_loc_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgecounter</span>
                <span class="n">next_simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">next_simp_pt_loc_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgecounter</span>
                <span class="n">edgecounter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">#  now for the while loop:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">next_simp_id_big</span> <span class="o">==</span> <span class="n">start_simp_id_big</span><span class="p">:</span>
                <span class="c1">#  get relptregion for next simp</span>
                <span class="n">ptr</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">next_simp_id_big</span><span class="p">][</span>
                    <span class="p">(</span><span class="n">next_simp_pt_loc_id_big</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">ptl</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">next_simp_id_big</span><span class="p">][</span>
                    <span class="p">(</span><span class="n">next_simp_pt_loc_id_big</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">rpl</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="n">ptl</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">])</span>
                       <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="n">ptr</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">]))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">next_simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">next_simp_pt_loc_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">rpl</span>
                <span class="n">next_simp</span><span class="o">.</span><span class="n">SLindex</span> <span class="o">=</span> <span class="n">next_simp_id</span>
                <span class="c1">#  save next simp as this simp</span>
                <span class="n">this_simp_id_big</span> <span class="o">=</span> <span class="n">next_simp_id_big</span>
                <span class="n">this_simp_pt_loc_id_big</span> <span class="o">=</span> <span class="n">next_simp_pt_loc_id_big</span>
                <span class="n">this_simp_pt_loc_id</span> <span class="o">=</span> <span class="n">next_simp_pt_loc_id</span>
                <span class="n">this_simp</span> <span class="o">=</span> <span class="n">next_simp</span>
                <span class="c1">#  find next simp</span>
                <span class="n">next_simp_id_big</span> <span class="o">=</span> <span class="n">temptri</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span>
                    <span class="n">this_simp_id_big</span><span class="p">][(</span><span class="n">this_simp_pt_loc_id_big</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">next_simp_pt_loc_id_big</span> <span class="o">=</span> <span class="p">(</span><span class="n">temptri</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span>
                    <span class="n">next_simp_id_big</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">this_simp_id_big</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
                <span class="n">next_simp_pt_loc_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">RelShift</span><span class="p">[</span><span class="n">next_simp_id_big</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                       <span class="o">+</span> <span class="n">next_simp_pt_loc_id_big</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
                <span class="n">next_simp_id</span> <span class="o">=</span> <span class="n">BigToLittleList</span><span class="p">[</span><span class="n">next_simp_id_big</span><span class="p">]</span>
                <span class="n">next_simp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">next_simp_id</span><span class="p">]</span>
                <span class="c1">#  linking the two simplices</span>
                <span class="n">this_simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">this_simp_pt_loc_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_simp</span>
                <span class="n">next_simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">next_simp_pt_loc_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_simp</span>
                <span class="k">if</span> <span class="n">this_simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">this_simp_pt_loc_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">this_simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">this_simp_pt_loc_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgecounter</span>
                    <span class="n">next_simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">next_simp_pt_loc_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">edgecounter</span>
                    <span class="n">edgecounter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span> <span class="o">=</span> <span class="n">edgecounter</span>

    <span class="k">def</span> <span class="nf">_LoadNewPos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptlist</span><span class="p">):</span>
        <span class="c1">#  putting the new point positions in pointposfuture</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span> <span class="o">=</span> <span class="n">ptlist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetNewPosCopyLoc</span><span class="p">()</span>
        <span class="c1">#  this will be updated as the points cross boundaries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_UpdatedFuturePosRelCopyLoc</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_GetNewPosCopyLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#  Function that takes all of the current and future positions and</span>
        <span class="c1">#  gets the copy of the FD that the future positions are in. Because</span>
        <span class="c1">#  the positions are constrained to be in the FD, we must find the</span>
        <span class="c1">#  copy (9 options) that has the smallest distance between the inital</span>
        <span class="c1">#  and proposed final positions.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Vec</span><span class="p">:</span>
            <span class="c1">#  vectorized version</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetNewPosCopyLocVec</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetNewPosCopyLocSingle</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_GetNewPosCopyLocSingle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">copyloc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Dxh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">Dyh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">)):</span>
            <span class="n">posi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">posf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="p">[</span><span class="n">posf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">posi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">posf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">posi</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">dzabs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">dz</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dz</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">if</span> <span class="n">dzabs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Dxh</span><span class="p">:</span>  <span class="c1"># x first</span>
                <span class="k">if</span> <span class="n">dzabs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Dyh</span><span class="p">:</span>
                    <span class="n">copyloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>   <span class="c1"># moved out of FD in y dir</span>
                    <span class="c1"># moved out of FD through bottom</span>
                    <span class="k">if</span> <span class="n">dz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">copyloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                    <span class="c1"># moved out through top</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">copyloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># moved out of FD in x dir</span>
                <span class="k">if</span> <span class="n">dz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># moved out of FD to left</span>
                    <span class="k">if</span> <span class="n">dzabs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Dyh</span><span class="p">:</span>
                        <span class="n">copyloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>   <span class="c1"># moved out of FD in y dir</span>
                        <span class="c1">#  moved out of FD through bottom</span>
                        <span class="k">if</span> <span class="n">dz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">copyloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">copyloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># moved out to the right</span>
                    <span class="k">if</span> <span class="n">dzabs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Dyh</span><span class="p">:</span>
                        <span class="n">copyloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># moved out of FD in y dir</span>
                        <span class="c1">#  moved out of FD through bottom</span>
                        <span class="k">if</span> <span class="n">dz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">copyloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">copyloc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">copyloc</span>

    <span class="k">def</span> <span class="nf">_GetNewPosCopyLocVec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#  vectorized version of above (usually faster)</span>
        <span class="n">posix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">)])</span>
        <span class="n">posiy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">)])</span>
        <span class="n">posfx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">)])</span>
        <span class="n">posfy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span><span class="p">)])</span>
        <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span>
        <span class="n">copyloc</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">CopyLocations</span><span class="p">(</span><span class="n">posix</span><span class="p">,</span> <span class="n">posiy</span><span class="p">,</span> <span class="n">posfx</span><span class="p">,</span> <span class="n">posfy</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">copyloc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<div class="viewcode-block" id="Triangulation2D.Evolve">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Triangulation2D.Evolve">[docs]</a>
    <span class="k">def</span> <span class="nf">Evolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ptlist</span><span class="p">,</span> <span class="n">Maintain_Delaunay</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evolve the triangulation forward.</span>

<span class="sd">        Main method for evolving the state of the triangulation forward in</span>
<span class="sd">        time.  This assumes that the starting triangulation is good</span>
<span class="sd">        (no negative areas).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ptlist : list</span>
<span class="sd">            The new time-slice data; the list of [x,y] positions for the</span>
<span class="sd">            points at the next time-step.</span>

<span class="sd">        Maintain_Delaunay : bool</span>
<span class="sd">            If Maintain_Delaunay is True (False is default), then after all</span>
<span class="sd">            of the collapse events are acounted for, extra edge flips will be</span>
<span class="sd">            used to ensure that the triangulation is Delaunay.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  Overview: load the new positions, find the events, deal with the</span>
        <span class="c1">#  events, update the current position, and maintain delaunay if</span>
        <span class="c1">#  needed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_LoadNewPos</span><span class="p">(</span><span class="n">ptlist</span><span class="p">)</span>
        <span class="n">EventLists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetEvents</span><span class="p">()</span>
        <span class="c1">#  GEvolve deals with the events in CollapseEventList</span>
        <span class="c1">#  and CrossingList (if periodic boundaries) in order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_GEvolve</span><span class="p">(</span><span class="n">EventLists</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_UpdatePtPos</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atstep</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">Maintain_Delaunay</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MakeDelaunay</span><span class="p">()</span></div>

            <span class="c1">#  after the atstep increment so that the operators</span>
            <span class="c1">#  will have the correct time-stamp.</span>

    <span class="k">def</span> <span class="nf">_GetEvents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_GetCollapseEvents</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetPtCrossEvents</span><span class="p">()]</span>

    <span class="k">def</span> <span class="nf">_GetCollapseEvents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find triangle collapse events.</span>

<span class="sd">        This finds all of the events where a triangle will go through zero</span>
<span class="sd">        area in the course of the points evolving from this time to the next</span>
<span class="sd">        time-step.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            A list of the simplices that collapse and the time of their</span>
<span class="sd">            collapse (bundled as a list of two items).  This list is sorted</span>
<span class="sd">            in decending order so that removing from the end (smallest times</span>
<span class="sd">            first) inccurs the smallest computational cost.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">collapsesimplist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Vec</span><span class="p">:</span>
            <span class="n">AZT_bool</span><span class="p">,</span> <span class="n">AZT_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AreaZeroTimeMultiple</span><span class="p">()</span>
            <span class="n">collapsesimplist</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">AZT_time</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">))</span>
                                <span class="k">if</span> <span class="n">AZT_bool</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
                <span class="n">AZT_bool</span><span class="p">,</span> <span class="n">AZT_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AreaZeroTimeSingle</span><span class="p">(</span><span class="n">simp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">AZT_bool</span><span class="p">:</span>
                    <span class="n">collapsesimplist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">simp</span><span class="p">,</span> <span class="n">AZT_time</span><span class="p">])</span>
        <span class="n">collapsesimplist</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">collapsesimplist</span>

    <span class="k">def</span> <span class="nf">_GetPtCrossEvents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#  We need to find, for each point, the time(s) it crosses any of</span>
        <span class="c1">#  the FD boundary lines and which line it crosses</span>
        <span class="n">CrossList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#  first get the list of future pos copy locations</span>
        <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span>
        <span class="n">Lines</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">Dy</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">Dy</span><span class="p">]],</span> <span class="p">[[</span><span class="n">Dx</span><span class="p">,</span> <span class="o">-</span><span class="n">Dy</span><span class="p">],</span> <span class="p">[</span><span class="n">Dx</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">Dy</span><span class="p">]],</span>
                 <span class="p">[[</span><span class="o">-</span><span class="n">Dx</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">Dx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[[</span><span class="o">-</span><span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">]]]</span>
        <span class="n">movedir</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">posi</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">posf</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">posfn</span> <span class="o">=</span> <span class="p">[</span><span class="n">posf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
                <span class="n">newline</span> <span class="o">=</span> <span class="p">[</span><span class="n">posi</span><span class="p">,</span> <span class="n">posfn</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Lines</span><span class="p">)):</span>
                    <span class="n">IsInt</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">IsIntersection</span><span class="p">(</span><span class="n">newline</span><span class="p">,</span> <span class="n">Lines</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">timeinfo</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">IsInt</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">CrossList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">IsInt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">movedir</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
        <span class="n">CrossList</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1">#  returns the point index, the time of crossing, and the move</span>
        <span class="c1">#  direction (-1,0,1 for both the x and y directions)</span>
        <span class="k">return</span> <span class="n">CrossList</span>

    <span class="k">def</span> <span class="nf">_AreaZeroTimeSingle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimpIn</span><span class="p">,</span> <span class="n">Tin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate collapse time.</span>

<span class="sd">        Finds whether (and when) a triangle (simp) goes through zero area.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        simp : Simplex2D object</span>
<span class="sd">            The simplex to consider.</span>

<span class="sd">        Tin : float</span>
<span class="sd">            The lower bound on the time window to consider.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Returns a pair [IsSoln, TimeOut], where IsSoln is a boolean that</span>
<span class="sd">            is True if the first time at which the area goes through zero is</span>
<span class="sd">            between Tin and 1, and False if not. For IsSoln == True,</span>
<span class="sd">            TimeOut gives this time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  first, by convention, we are going to take a specific copy of</span>
        <span class="c1">#  this simplex ... the one where the first point stored in the</span>
        <span class="c1">#  simplex is considered to be in the fundamental domain.  For</span>
        <span class="c1">#  boundary simplices, this gives us one copy to consider.</span>
        <span class="n">ptlist</span> <span class="o">=</span> <span class="n">SimpIn</span><span class="o">.</span><span class="n">points</span>
        <span class="n">rpr</span> <span class="o">=</span> <span class="n">SimpIn</span><span class="o">.</span><span class="n">relptregion</span>
        <span class="n">pt1shift</span> <span class="o">=</span> <span class="n">rpr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">pt2shift</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">rpr</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">rpr</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1">#  now shift the Initial and Final points appropriately</span>
        <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span>
        <span class="n">Initpos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">Tin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">Initpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">ptlist</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">Initpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">ptlist</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">CurrentLoc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetCurrentLoc</span><span class="p">(</span><span class="n">ptlist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Tin</span><span class="p">)</span>
                <span class="n">Initpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CurrentLoc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">Initpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CurrentLoc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Finalpos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">Finalpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">ptlist</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">Finalpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">ptlist</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">Initpos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt1shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Initpos</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt1shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Finalpos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt1shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Finalpos</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt1shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Initpos</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt2shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Initpos</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt2shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Finalpos</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt2shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Finalpos</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt2shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#  Finally, we see if any of the final points have crossed a</span>
        <span class="c1">#  boundary, and correct for this (notice that we used the</span>
        <span class="c1">#  updated version)</span>
        <span class="n">cploc</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_UpdatedFuturePosRelCopyLoc</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ptlist</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">Finalpos</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">cploc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Finalpos</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">cploc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">AZT_bool</span><span class="p">,</span> <span class="n">AZT_time</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">AreaZeroTimeBaseSingle</span><span class="p">(</span>
            <span class="n">Initpos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Initpos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Initpos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Initpos</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">Initpos</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
            <span class="n">Initpos</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">Finalpos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Finalpos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Finalpos</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Finalpos</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
            <span class="n">Finalpos</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">Finalpos</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1">#  now, the returned time is between 0 and 1, while we need a time</span>
        <span class="c1">#  between Tin and 1, so we uniformly contract this time</span>
        <span class="k">if</span> <span class="n">AZT_bool</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">Tin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">AZT_time</span> <span class="o">=</span> <span class="n">AZT_time</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Tin</span><span class="p">)</span> <span class="o">+</span> <span class="n">Tin</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">AZT_bool</span><span class="p">,</span> <span class="n">AZT_time</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_AreaZeroTimeMultiple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Tin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Vectorized calculation of collapse times.</span>

<span class="sd">        Goes through every simplex and looks for whether the area zero time</span>
<span class="sd">        is between Tin and 1.  Similar to AreaZeroTimeSingle, but wrapping up</span>
<span class="sd">        the info in numpy arrays to get vectorization and jit boost.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Tin : float</span>
<span class="sd">            The lower bound on the time window to consider.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            list of booleans, indicating whether the simplex (with this</span>
<span class="sd">            index) collapsed within the interval.</span>

<span class="sd">        list</span>
<span class="sd">            list of floats, giving the collapse times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span>
        <span class="n">nsimps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">)</span>
        <span class="n">pts0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pts2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">npptpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span>
        <span class="n">npptposf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">)</span>
        <span class="n">IP0x</span><span class="p">,</span> <span class="n">IP0y</span> <span class="o">=</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">IP1x</span><span class="p">,</span> <span class="n">IP1y</span> <span class="o">=</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">IP2x</span><span class="p">,</span> <span class="n">IP2y</span> <span class="o">=</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptpos</span><span class="p">[</span><span class="n">pts2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">FP0x</span><span class="p">,</span> <span class="n">FP0y</span> <span class="o">=</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">FP1x</span><span class="p">,</span> <span class="n">FP1y</span> <span class="o">=</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">FP2x</span><span class="p">,</span> <span class="n">FP2y</span> <span class="o">=</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">npptposf</span><span class="p">[</span><span class="n">pts2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">pt1shiftx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pt1shifty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pt2shiftx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pt2shifty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">IP1x</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt1shiftx</span>
        <span class="n">IP1y</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt1shifty</span>
        <span class="n">FP1x</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt1shiftx</span>
        <span class="n">FP1y</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt1shifty</span>
        <span class="n">IP2x</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt2shiftx</span>
        <span class="n">IP2y</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt2shifty</span>
        <span class="n">FP2x</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt2shiftx</span>
        <span class="n">FP2y</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt2shifty</span>
        <span class="n">pt0finalshiftx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span><span class="p">[</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]]][</span><span class="mi">0</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pt0finalshifty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span><span class="p">[</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]]][</span><span class="mi">1</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pt1finalshiftx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span><span class="p">[</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]]][</span><span class="mi">0</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pt1finalshifty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span><span class="p">[</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]]][</span><span class="mi">1</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pt2finalshiftx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span><span class="p">[</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]]][</span><span class="mi">0</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">pt2finalshifty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span><span class="p">[</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]]][</span><span class="mi">1</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsimps</span><span class="p">)])</span>
        <span class="n">FP0x</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt0finalshiftx</span>
        <span class="n">FP0y</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt0finalshifty</span>
        <span class="n">FP1x</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt1finalshiftx</span>
        <span class="n">FP1y</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt1finalshifty</span>
        <span class="n">FP2x</span> <span class="o">+=</span> <span class="n">Dx</span><span class="o">*</span><span class="n">pt2finalshiftx</span>
        <span class="n">FP2y</span> <span class="o">+=</span> <span class="n">Dy</span><span class="o">*</span><span class="n">pt2finalshifty</span>
        <span class="c1">#  vectorized (+jit)</span>
        <span class="k">return</span> <span class="n">HF</span><span class="o">.</span><span class="n">AreaZeroTimeBaseVec</span><span class="p">(</span><span class="n">IP0x</span><span class="p">,</span> <span class="n">IP0y</span><span class="p">,</span> <span class="n">IP1x</span><span class="p">,</span> <span class="n">IP1y</span><span class="p">,</span> <span class="n">IP2x</span><span class="p">,</span> <span class="n">IP2y</span><span class="p">,</span>
                                      <span class="n">FP0x</span><span class="p">,</span> <span class="n">FP0y</span><span class="p">,</span> <span class="n">FP1x</span><span class="p">,</span> <span class="n">FP1y</span><span class="p">,</span> <span class="n">FP2x</span><span class="p">,</span> <span class="n">FP2y</span><span class="p">,</span> <span class="n">Tin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_GEvolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">EventLists</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process the events in EventLists.</span>

<span class="sd">        Processes an ordered list of events (collapse) and does edge flips to</span>
<span class="sd">        update the triangulation.  Also adds in new events as needed. Finished</span>
<span class="sd">        when there are no more events in the time interval, and the</span>
<span class="sd">        triangulation is consistent with the new set of points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">EventListSimp</span><span class="p">,</span> <span class="n">EventListCrossing</span> <span class="o">=</span> <span class="n">EventLists</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">EventListSimp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">EventListCrossing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">latestSimpEventTime</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">latestCrossingEventTime</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">EventListSimp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">latestSimpEventTime</span> <span class="o">=</span> <span class="n">EventListSimp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">EventListCrossing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">latestCrossingEventTime</span> <span class="o">=</span> <span class="n">EventListCrossing</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">latestSimpEventTime</span> <span class="o">&lt;</span> <span class="n">latestCrossingEventTime</span><span class="p">:</span>
                <span class="c1">#  here we deal with simplex collapse events</span>
                <span class="n">CollSimp</span><span class="p">,</span> <span class="n">currenttime</span> <span class="o">=</span> <span class="n">EventListSimp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#  deal with simplex collapse events here</span>
                <span class="c1">#  returns ... [[leftsimp,rightsimp],topsimp (old)]</span>
                <span class="n">newsimps</span><span class="p">,</span> <span class="n">delsimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SFix</span><span class="p">(</span><span class="n">CollSimp</span><span class="p">,</span> <span class="n">currenttime</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">EventListSimp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># get rid of the evaluated event</span>
                <span class="c1">#  first find the time of zero area for potential top</span>
                <span class="c1">#  simplex event, and delete it if it is in the eventlist</span>
                <span class="n">collapsed</span><span class="p">,</span> <span class="n">collapse_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AreaZeroTimeSingle</span><span class="p">(</span>
                    <span class="n">delsimp</span><span class="p">,</span> <span class="n">currenttime</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">collapsed</span><span class="p">:</span>
                    <span class="n">HF</span><span class="o">.</span><span class="n">BinarySearchDel</span><span class="p">(</span><span class="n">EventListSimp</span><span class="p">,</span> <span class="p">[</span><span class="n">delsimp</span><span class="p">,</span> <span class="n">collapse_time</span><span class="p">])</span>
                <span class="c1">#  now run through the newsimps list and see if each object</span>
                <span class="c1">#  goes through zero area in the remaining time (if so, add to</span>
                <span class="c1">#  EventList with the calulated time to zero area)</span>
                <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="n">newsimps</span><span class="p">:</span>
                    <span class="n">collapsed</span><span class="p">,</span> <span class="n">collapse_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AreaZeroTimeSingle</span><span class="p">(</span>
                        <span class="n">simp</span><span class="p">,</span> <span class="n">currenttime</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span>
                    <span class="c1"># insert in the event list at the correct spot</span>
                    <span class="k">if</span> <span class="n">collapsed</span><span class="p">:</span>
                        <span class="n">HF</span><span class="o">.</span><span class="n">BinarySearchIns</span><span class="p">(</span><span class="n">EventListSimp</span><span class="p">,</span>
                                           <span class="p">[</span><span class="n">simp</span><span class="p">,</span> <span class="n">collapse_time</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#  here we deal with the crossing events</span>
                <span class="n">currenttime</span> <span class="o">=</span> <span class="n">latestCrossingEventTime</span>
                <span class="n">ptindex</span> <span class="o">=</span> <span class="n">EventListCrossing</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ptmove</span> <span class="o">=</span> <span class="n">EventListCrossing</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># update self.UpdatedFuturePosRelCopyLoc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_UpdatedFuturePosRelCopyLoc</span><span class="p">[</span><span class="n">ptindex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">ptmove</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_UpdatedFuturePosRelCopyLoc</span><span class="p">[</span><span class="n">ptindex</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">ptmove</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#  We need to update the relative position data in every</span>
                <span class="c1">#  simplex that shares this point</span>
                <span class="c1">#  first get a list of all the simplices that bound this point</span>
                <span class="n">Sset</span><span class="p">,</span> <span class="n">SLid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">ptindex</span><span class="p">]</span><span class="o">.</span><span class="n">SimpNeighbors</span><span class="p">(</span><span class="n">ptindex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">simp</span><span class="p">,</span> <span class="n">locid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Sset</span><span class="p">,</span> <span class="n">SLid</span><span class="p">):</span>
                    <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ptmove</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ptmove</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">ptmove</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">ptmove</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1">#  now we need to delete the crossing event</span>
                <span class="k">del</span> <span class="n">EventListCrossing</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_SFix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimpIn</span><span class="p">,</span> <span class="n">tcollapse</span><span class="p">):</span>
        <span class="c1">#  Fixing a simplex and the surrounding affected simplices. This</span>
        <span class="c1">#  returns the two new simplices, so that they can be possibly added</span>
        <span class="c1">#  to the local event list, also the bad simplex so it can be removed</span>
        <span class="c1">#  (if needed from the local event list)</span>

        <span class="c1">#  `colind` is the local index of the offending point during the</span>
        <span class="c1">#  area collapse</span>
        <span class="n">colind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CollapsePt</span><span class="p">(</span><span class="n">SimpIn</span><span class="p">,</span> <span class="n">tcollapse</span><span class="p">)</span>
        <span class="n">Topsimp</span> <span class="o">=</span> <span class="n">SimpIn</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">colind</span><span class="p">]</span>
        <span class="n">edge_id</span> <span class="o">=</span> <span class="n">SimpIn</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">colind</span><span class="p">]</span>
        <span class="n">globaltime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atstep</span> <span class="o">+</span> <span class="n">tcollapse</span>
        <span class="n">newsimps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EdgeFlip</span><span class="p">([</span><span class="n">SimpIn</span><span class="p">,</span> <span class="n">Topsimp</span><span class="p">],</span> <span class="n">edge_id</span><span class="p">,</span> <span class="n">globaltime</span><span class="p">)</span>
        <span class="c1">#  EdgeFlip does most of the work in flipping the edge and</span>
        <span class="c1">#  cleaning up linking</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">newsimps</span><span class="p">,</span> <span class="n">Topsimp</span><span class="p">]</span>
        <span class="c1">#  return the two new simplices, so that they can be checked to see</span>
        <span class="c1">#  if they need to be included in any update to the local event list.</span>
        <span class="c1">#  Also return the bad simplex to remove any instance from the</span>
        <span class="c1">#  event list.</span>

    <span class="k">def</span> <span class="nf">_CollapsePt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimpIn</span><span class="p">,</span> <span class="n">tcol</span><span class="p">):</span>
        <span class="c1">#  This returns the point (internal id) that passes through its</span>
        <span class="c1">#  opposite edge during an area collapse event known to occur</span>
        <span class="c1">#  at t = tcol</span>
        <span class="c1">#  first get the positions of the 3 points at the time of collapse</span>
        <span class="n">colpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GetSimpCurrentLoc</span><span class="p">(</span><span class="n">SimpIn</span><span class="p">,</span> <span class="n">tcol</span><span class="p">)</span>
        <span class="n">d0</span> <span class="o">=</span> <span class="p">((</span><span class="n">colpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
              <span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1">#  This is the dot product of (z2-z0) and (z1-z0)</span>
        <span class="k">if</span> <span class="n">d0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="p">((</span><span class="n">colpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                  <span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">colpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">colpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">d1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="c1">#  Note: don&#39;t need to calculate the last dot product.</span>
            <span class="c1">#  If the first two are &gt;0, this must be &lt;0</span>

    <span class="k">def</span> <span class="nf">_GetSimpCurrentLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimpIn</span><span class="p">,</span> <span class="n">timeIn</span><span class="p">):</span>
        <span class="n">ptlist</span> <span class="o">=</span> <span class="n">SimpIn</span><span class="o">.</span><span class="n">points</span>
        <span class="n">rpr</span> <span class="o">=</span> <span class="n">SimpIn</span><span class="o">.</span><span class="n">relptregion</span>
        <span class="c1"># now shift the Initial and Final points appropriately</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_GetCurrentLoc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">timeIn</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ptlist</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">rpr</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">rpr</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">_GetCurrentLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PtInd</span><span class="p">,</span> <span class="n">timeIn</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1">#  gets the current position of a given point (pass in a point index)</span>
        <span class="c1">#  by taking the linear interpolation from the initial position to</span>
        <span class="c1">#  the final postion, then moding by the boundary size so that the</span>
        <span class="c1">#  point is in the FD.  timeIn is in [0,1]</span>
        <span class="n">posi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">PtInd</span><span class="p">]</span>
        <span class="n">posf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">[</span><span class="n">PtInd</span><span class="p">]</span>
        <span class="n">posfn</span> <span class="o">=</span> <span class="p">[</span><span class="n">posf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dpindices</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_FuturePosRelCopyLoc</span><span class="p">[</span><span class="n">PtInd</span><span class="p">]][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">mod</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[((</span><span class="n">posfn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">posi</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">*</span><span class="n">timeIn</span> <span class="o">+</span> <span class="n">posi</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[((</span><span class="n">posfn</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">posi</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">*</span><span class="n">timeIn</span> <span class="o">+</span> <span class="n">posi</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_EdgeFlip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AdjSimps</span><span class="p">,</span> <span class="n">EdgeShare</span><span class="p">,</span> <span class="n">TimeIn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flip an edge in the triangulation.</span>

<span class="sd">        EdgeFlip locally re-triangulates the triangulation by removing an</span>
<span class="sd">        edge that divides two adjacent triangles in a quadrilateral, and</span>
<span class="sd">        replaces it with the other diagonal of this quadrilateral.  This</span>
<span class="sd">        removes the old simplices, creates new ones, and links them up in the</span>
<span class="sd">        triangulation. EdgeFlip also creates the appropriate WeightOperator</span>
<span class="sd">        object and adds it to the WeightOperator list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        AdjSimps : list of 2 Simplex2D objects</span>
<span class="sd">            These are the two simplices that share the edge to be flipped</span>

<span class="sd">        EdgeShare : int</span>
<span class="sd">            The edge id of the edge to be flipped.  While this can almost</span>
<span class="sd">            always be found from AdjSimps, the redundancy helps in certain</span>
<span class="sd">            cases.</span>

<span class="sd">        TimeIn : float</span>
<span class="sd">            This is the time when the event occured that required a flip.</span>
<span class="sd">            It is added as part of the data in the WeightOperator object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of 2 Simplex2D objects</span>
<span class="sd">            The two new simplices.  Returned so that the calling function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  first get the local ids of the points not shared by these simplices</span>
        <span class="n">Simp</span> <span class="o">=</span> <span class="n">AdjSimps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Topsimp</span> <span class="o">=</span> <span class="n">AdjSimps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bptlid</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">EdgeShare</span><span class="p">)</span>
        <span class="n">bpt</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">bptlid</span><span class="p">]</span>
        <span class="n">rptlid</span> <span class="o">=</span> <span class="p">(</span><span class="n">bptlid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
        <span class="n">lptlid</span> <span class="o">=</span> <span class="p">(</span><span class="n">bptlid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
        <span class="n">rpt</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">rptlid</span><span class="p">]</span>
        <span class="n">lpt</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">lptlid</span><span class="p">]</span>
        <span class="n">tptuid</span> <span class="o">=</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">EdgeShare</span><span class="p">)</span>
        <span class="n">tpt</span> <span class="o">=</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">tptuid</span><span class="p">]</span>
        <span class="n">lptuid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tptuid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
        <span class="n">rptuid</span> <span class="o">=</span> <span class="p">(</span><span class="n">tptuid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
        <span class="n">rslist</span> <span class="o">=</span> <span class="p">[</span><span class="n">bpt</span><span class="p">,</span> <span class="n">rpt</span><span class="p">,</span> <span class="n">tpt</span><span class="p">]</span>
        <span class="n">lslist</span> <span class="o">=</span> <span class="p">[</span><span class="n">bpt</span><span class="p">,</span> <span class="n">tpt</span><span class="p">,</span> <span class="n">lpt</span><span class="p">]</span>
        <span class="n">rsimp</span> <span class="o">=</span> <span class="n">Simplex2D</span><span class="p">(</span><span class="n">rslist</span><span class="p">)</span>  <span class="c1"># new right simplex</span>
        <span class="n">lsimp</span> <span class="o">=</span> <span class="n">Simplex2D</span><span class="p">(</span><span class="n">lslist</span><span class="p">)</span>  <span class="c1"># new left simplex</span>
        <span class="c1">#  create the list of edge ids for the weight operator</span>
        <span class="n">WeightIDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">EdgeShare</span><span class="p">,</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">lptuid</span><span class="p">],</span>
                     <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">rptuid</span><span class="p">],</span> <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">rptlid</span><span class="p">],</span>
                     <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">lptlid</span><span class="p">]]</span>
        <span class="c1">#  create the weight operater and append to the list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">WeightOperator</span><span class="p">(</span><span class="n">WeightIDs</span><span class="p">,</span> <span class="n">TimeIn</span><span class="p">))</span>
        <span class="c1">#  need to create the relptregion data for the new simplices</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">rsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">lptuid</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="n">rsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Topsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">rptuid</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                                       <span class="o">+</span> <span class="n">Simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">rptlid</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
            <span class="n">rsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">lptlid</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="n">lsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">rptuid</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="n">lsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">rptlid</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="n">lsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Topsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">lptuid</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                                       <span class="o">+</span> <span class="n">Simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">lptlid</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
        <span class="c1">#  now create the links these simplices have to other simplices</span>
        <span class="c1">#  first determine if this is a case where some of the adjacent</span>
        <span class="c1">#  simplices are either Simp or Topsimp</span>
        <span class="k">if</span> <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">rptlid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">lptuid</span><span class="p">]:</span>
            <span class="n">Topsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">rptuid</span><span class="p">]</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">lsimp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                               <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">rptuid</span><span class="p">])</span>
            <span class="n">Simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">lptlid</span><span class="p">]</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">rsimp</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                            <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">lptlid</span><span class="p">])</span>
            <span class="n">rsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsimp</span>
            <span class="n">lsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsimp</span>
        <span class="k">elif</span> <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">lptlid</span><span class="p">]</span> <span class="o">==</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">rptuid</span><span class="p">]:</span>
            <span class="n">Topsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">lptuid</span><span class="p">]</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">rsimp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                               <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">lptuid</span><span class="p">])</span>
            <span class="n">Simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">rptlid</span><span class="p">]</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">lsimp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                                            <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">rptlid</span><span class="p">])</span>
            <span class="n">rsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsimp</span>
            <span class="n">lsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsimp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#  regular case</span>
            <span class="n">Topsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">lptuid</span><span class="p">]</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">rsimp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                               <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">lptuid</span><span class="p">])</span>
            <span class="n">Topsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">rptuid</span><span class="p">]</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">lsimp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                               <span class="n">Topsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">rptuid</span><span class="p">])</span>
            <span class="n">Simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">lptlid</span><span class="p">]</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">rsimp</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">lptlid</span><span class="p">])</span>
            <span class="n">Simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">rptlid</span><span class="p">]</span><span class="o">.</span><span class="n">SimpLink</span><span class="p">(</span><span class="n">lsimp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">rptlid</span><span class="p">])</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsimp</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsimp</span>
        <span class="c1">#  also need to reassign the weight ids</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">WeightIDs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#  replace the two bad simplices in the simplex list</span>
        <span class="c1">#  with the two new ones</span>
        <span class="n">Simpindex</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">SLindex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">Simpindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsimp</span>
        <span class="n">lsimp</span><span class="o">.</span><span class="n">SLindex</span> <span class="o">=</span> <span class="n">Simpindex</span>
        <span class="n">Topsimpindex</span> <span class="o">=</span> <span class="n">Topsimp</span><span class="o">.</span><span class="n">SLindex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">Topsimpindex</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsimp</span>
        <span class="n">rsimp</span><span class="o">.</span><span class="n">SLindex</span> <span class="o">=</span> <span class="n">Topsimpindex</span>
        <span class="c1">#  look through the simplex point list to see if either of the bad</span>
        <span class="c1">#  simplices were there and replace if so</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">bpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Simp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">bpt</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsimp</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">rpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Simp</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">rpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Topsimp</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">rpt</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsimp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">tpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Topsimp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">tpt</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsimp</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">lpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Simp</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">lpt</span><span class="p">]</span> <span class="ow">is</span> <span class="n">Topsimp</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">lpt</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsimp</span>
        <span class="c1">#  Next, delete all the references to simplices in both</span>
        <span class="c1">#  of the bad simplices</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">Simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Topsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">lsimp</span><span class="p">,</span> <span class="n">rsimp</span><span class="p">]</span>

<div class="viewcode-block" id="Triangulation2D.MakeDelaunay">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Triangulation2D.MakeDelaunay">[docs]</a>
    <span class="k">def</span> <span class="nf">MakeDelaunay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flip edges until the triangulation is Delaunay.</span>

<span class="sd">        MakeDelaunay takes the current triangulation and, through a series</span>
<span class="sd">        of edge flips, changes it into the Delaunay triangulation for this</span>
<span class="sd">        point configuration.  This function changes the underlying</span>
<span class="sd">        triangulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">IsD</span><span class="p">,</span> <span class="n">EdgeBSimps</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1">#  vectorized version (this one only makes marginal improvements)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Vec</span><span class="p">:</span>
            <span class="n">IsD</span><span class="p">,</span> <span class="n">EdgeBSimps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsDelaunay</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">EdgeBSimps</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
            <span class="n">EdgeUsed</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
            <span class="n">IsD</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">edgeid</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">EdgeUsed</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]:</span>
                        <span class="n">EdgeUsed</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">EdgeBSimps</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">simp</span><span class="p">,</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span>
                                              <span class="n">edgeid</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
                        <span class="n">IsD</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsLocallyDelaunay</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">simp</span><span class="p">,</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">edgeid</span><span class="p">)</span>
        <span class="n">EdgeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">EdgeBSimps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">IsD</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">EdgeList_Epos</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EdgeList</span><span class="p">)):</span>
            <span class="n">EdgeList_Epos</span><span class="p">[</span><span class="n">EdgeList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="c1">#  now go through the edge list and start flipping edges</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">EdgeList</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">EdgeSimps</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">,</span> <span class="n">checked</span> <span class="o">=</span> <span class="n">EdgeList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">EdgeList_Epos</span><span class="p">[</span><span class="n">edge_id</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">Flip</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">checked</span><span class="p">:</span>
                <span class="n">Flip</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsLocallyDelaunay</span><span class="p">(</span><span class="n">EdgeSimps</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Flip</span><span class="p">:</span>
                <span class="n">LRsimps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EdgeFlip</span><span class="p">(</span><span class="n">EdgeSimps</span><span class="p">,</span> <span class="n">edge_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atstep</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># Left and right simplices</span>
                    <span class="n">loc</span> <span class="o">=</span> <span class="n">LRsimps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge_id</span><span class="p">)</span>
                    <span class="n">lrsimp</span> <span class="o">=</span> <span class="n">LRsimps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># upper and lower simplices</span>
                        <span class="n">eid</span> <span class="o">=</span> <span class="n">lrsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">loc</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                        <span class="n">adjsimp</span> <span class="o">=</span> <span class="n">lrsimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">loc</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                        <span class="n">ELinsert</span> <span class="o">=</span> <span class="p">[[</span><span class="n">lrsimp</span><span class="p">,</span> <span class="n">adjsimp</span><span class="p">],</span> <span class="n">eid</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">EdgeList_Epos</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">EdgeList_Epos</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">EdgeList</span><span class="p">)</span>
                            <span class="n">EdgeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ELinsert</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">EdgeList</span><span class="p">[</span><span class="n">EdgeList_Epos</span><span class="p">[</span><span class="n">eid</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ELinsert</span></div>


    <span class="k">def</span> <span class="nf">_IsDelaunay</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is the triangulation Delaunay.</span>

<span class="sd">        IsDelaunay outputs an array (length = number of edges) of booleans,</span>
<span class="sd">        which indicate if the quadrilateral with the ith edge as a diagonal is</span>
<span class="sd">        Delaunay. Also outputs an array of the pairs of simplices which bound</span>
<span class="sd">        each edge. This calls IsDelaunayBase (from a helper function module)</span>
<span class="sd">        for a jit speed-up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ax</span><span class="p">,</span> <span class="n">Ay</span><span class="p">,</span> <span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">,</span> <span class="n">Cx</span><span class="p">,</span> <span class="n">Cy</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)</span>
                                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>
        <span class="n">EdgeUsed</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
        <span class="n">BoundingSimps</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">edgeid</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">EdgeUsed</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]:</span>
                    <span class="n">EdgeUsed</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">Apt</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">Ax</span><span class="p">[</span><span class="n">edgeid</span><span class="p">],</span> <span class="n">Ay</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Apt</span><span class="p">]</span>
                    <span class="n">Bpt</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">Bx</span><span class="p">[</span><span class="n">edgeid</span><span class="p">],</span> <span class="n">By</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Bpt</span><span class="p">]</span>
                    <span class="n">Cpt</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">Cx</span><span class="p">[</span><span class="n">edgeid</span><span class="p">],</span> <span class="n">Cy</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Cpt</span><span class="p">]</span>
                    <span class="n">adjsimp</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">BoundingSimps</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">simp</span><span class="p">,</span> <span class="n">adjsimp</span><span class="p">],</span> <span class="n">edgeid</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
                    <span class="n">adjsimp_loc_id</span> <span class="o">=</span> <span class="n">adjsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edgeid</span><span class="p">)</span>
                    <span class="n">Dpt</span> <span class="o">=</span> <span class="n">adjsimp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">adjsimp_loc_id</span><span class="p">]</span>
                    <span class="n">Dx</span><span class="p">[</span><span class="n">edgeid</span><span class="p">],</span> <span class="n">Dy</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Dpt</span><span class="p">]</span>
                    <span class="c1"># now need to modify point positions.</span>
                    <span class="c1"># Will use pt A as reference point (in FD)</span>
                    <span class="n">Bx</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">+=</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">By</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">+=</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">Cx</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">-=</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">Cy</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">-=</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">Dx</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">-=</span> <span class="n">adjsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">adjsimp_loc_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">Dy</span><span class="p">[</span><span class="n">edgeid</span><span class="p">]</span> <span class="o">-=</span> <span class="n">adjsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">adjsimp_loc_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">HF</span><span class="o">.</span><span class="n">IsDelaunayBase</span><span class="p">(</span><span class="n">Ax</span><span class="p">,</span> <span class="n">Ay</span><span class="p">,</span> <span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">,</span> <span class="n">Cx</span><span class="p">,</span> <span class="n">Cy</span><span class="p">,</span> <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span><span class="p">),</span> <span class="n">BoundingSimps</span>

    <span class="k">def</span> <span class="nf">_IsLocallyDelaunay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AdjSimps</span><span class="p">,</span> <span class="n">edgeid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is the quadrilateral Delaunay.</span>

<span class="sd">        Given the two adjacent simplices, this determine if the</span>
<span class="sd">        configuration is locally Delaunay.  Returns True or False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">simp</span> <span class="o">=</span> <span class="n">AdjSimps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">locid</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edgeid</span><span class="p">)</span>
        <span class="n">Apt</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">Ax</span><span class="p">,</span> <span class="n">Ay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Apt</span><span class="p">]</span>
        <span class="n">Bpt</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">locid</span><span class="p">]</span>
        <span class="n">Bx</span><span class="p">,</span> <span class="n">By</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Bpt</span><span class="p">]</span>
        <span class="n">Cpt</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">Cx</span><span class="p">,</span> <span class="n">Cy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Cpt</span><span class="p">]</span>
        <span class="n">adjsimp</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">locid</span><span class="p">]</span>
        <span class="n">adjsimp_loc_id</span> <span class="o">=</span> <span class="n">adjsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edgeid</span><span class="p">)</span>
        <span class="n">Dpt</span> <span class="o">=</span> <span class="n">adjsimp</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">adjsimp_loc_id</span><span class="p">]</span>
        <span class="n">Dx</span><span class="p">,</span> <span class="n">Dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Dpt</span><span class="p">]</span>
        <span class="c1">#  now need to modify point positions.</span>
        <span class="c1">#  Will use pt A as reference point (in FD)</span>
        <span class="n">Bx</span> <span class="o">+=</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">By</span> <span class="o">+=</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Cx</span> <span class="o">-=</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">locid</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Cy</span> <span class="o">-=</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">locid</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Dx</span> <span class="o">-=</span> <span class="n">adjsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">adjsimp_loc_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Dy</span> <span class="o">-=</span> <span class="n">adjsimp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">adjsimp_loc_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ADx</span> <span class="o">=</span> <span class="n">Ax</span> <span class="o">-</span> <span class="n">Dx</span>
        <span class="n">ADy</span> <span class="o">=</span> <span class="n">Ay</span> <span class="o">-</span> <span class="n">Dy</span>
        <span class="n">BDx</span> <span class="o">=</span> <span class="n">Bx</span> <span class="o">-</span> <span class="n">Dx</span>
        <span class="n">BDy</span> <span class="o">=</span> <span class="n">By</span> <span class="o">-</span> <span class="n">Dy</span>
        <span class="n">CDx</span> <span class="o">=</span> <span class="n">Cx</span> <span class="o">-</span> <span class="n">Dx</span>
        <span class="n">CDy</span> <span class="o">=</span> <span class="n">Cy</span> <span class="o">-</span> <span class="n">Dy</span>
        <span class="n">AD2</span> <span class="o">=</span> <span class="n">ADx</span><span class="o">*</span><span class="n">ADx</span> <span class="o">+</span> <span class="n">ADy</span><span class="o">*</span><span class="n">ADy</span>
        <span class="n">BD2</span> <span class="o">=</span> <span class="n">BDx</span><span class="o">*</span><span class="n">BDx</span> <span class="o">+</span> <span class="n">BDy</span><span class="o">*</span><span class="n">BDy</span>
        <span class="n">CD2</span> <span class="o">=</span> <span class="n">CDx</span><span class="o">*</span><span class="n">CDx</span> <span class="o">+</span> <span class="n">CDy</span><span class="o">*</span><span class="n">CDy</span>
        <span class="n">detvals</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADx</span><span class="o">*</span><span class="p">(</span><span class="n">BDy</span><span class="o">*</span><span class="n">CD2</span> <span class="o">-</span> <span class="n">CDy</span><span class="o">*</span><span class="n">BD2</span><span class="p">)</span>
                   <span class="o">-</span> <span class="n">ADy</span><span class="o">*</span><span class="p">(</span><span class="n">BDx</span><span class="o">*</span><span class="n">CD2</span> <span class="o">-</span> <span class="n">CDx</span><span class="o">*</span><span class="n">BD2</span><span class="p">)</span>
                   <span class="o">+</span> <span class="n">AD2</span><span class="o">*</span><span class="p">(</span><span class="n">BDx</span><span class="o">*</span><span class="n">CDy</span> <span class="o">-</span> <span class="n">CDx</span><span class="o">*</span><span class="n">BDy</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">detvals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="Triangulation2D.OperatorAction">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Triangulation2D.OperatorAction">[docs]</a>
    <span class="k">def</span> <span class="nf">OperatorAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">option</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flip operator acting on a Loop.</span>

<span class="sd">        OperatorAction takes the accumulated operator list stored in</span>
<span class="sd">        WeightOperatorList and operates sucessively on the given Loop</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        LoopIn : Loop Object</span>
<span class="sd">            The weightlist of this loop will be modified in place</span>

<span class="sd">        index : list of 2 ints</span>
<span class="sd">            the start and stop index can also be specified to break this up</span>
<span class="sd">            into stages (only used for option 1 and 2). Default is None</span>

<span class="sd">        Reverse : bool</span>
<span class="sd">            Reverse does the operator actions in reverse order (i.e. for</span>
<span class="sd">            loops in the final triangulation)</span>

<span class="sd">        option : int {1,2,3}</span>
<span class="sd">            option 1 just changes the data in the loop object</span>
<span class="sd">            option 2 also accumulates a weight list with the total weights</span>
<span class="sd">            after each operator has acted on the loop, and gives the global</span>
<span class="sd">            time of the operator action.</span>
<span class="sd">            option 3 (the default) returns a weight list which has the weights</span>
<span class="sd">            at the end of each time step (the intervals between each use of</span>
<span class="sd">            the Evolve method). This weight list does not have the time listed,</span>
<span class="sd">            as this is only know externally. this is most useful for producing</span>
<span class="sd">            a list that we can directly tie to an external list of times.</span>
<span class="sd">            This is what we need for extracting the topological entropy</span>
<span class="sd">            (hence the default option).</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        No return - option 1</span>
<span class="sd">        list of floats - option 2 and 3 (list is weightlist)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">startind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">endind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">startind</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">endind</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Reverse</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startind</span><span class="p">,</span> <span class="n">endind</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">endind</span><span class="p">,</span> <span class="n">startind</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">,</span> <span class="n">Reverse</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">WeightList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Reverse</span><span class="p">:</span>
                <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">(),</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startind</span><span class="p">,</span> <span class="n">endind</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">)</span>
                    <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">(),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">finaltime</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">(),</span> <span class="n">finaltime</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">endind</span><span class="p">,</span> <span class="n">startind</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">,</span> <span class="n">Reverse</span><span class="p">)</span>
                    <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">(),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">WeightList</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">WeightList</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Reverse</span><span class="p">:</span>
                <span class="n">prevtime</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">)):</span>
                    <span class="n">thistime</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">thistime</span> <span class="o">&gt;</span> <span class="n">prevtime</span><span class="p">:</span>
                        <span class="n">prevtime</span> <span class="o">=</span> <span class="n">thistime</span>
                        <span class="n">currentweight</span> <span class="o">=</span> <span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">()</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">WeightList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thistime</span><span class="p">:</span>
                            <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentweight</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">)</span>
                <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                <span class="n">prevtime</span> <span class="o">=</span> <span class="n">endtime</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">thistime</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">thistime</span> <span class="o">&lt;</span> <span class="n">prevtime</span><span class="p">:</span>
                        <span class="n">prevtime</span> <span class="o">=</span> <span class="n">thistime</span>
                        <span class="n">currentweight</span> <span class="o">=</span> <span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">()</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">WeightList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">endtime</span><span class="o">-</span><span class="n">thistime</span><span class="p">:</span>
                            <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentweight</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Update</span><span class="p">(</span><span class="n">LoopIn</span><span class="p">,</span> <span class="n">Reverse</span><span class="p">)</span>
                <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">GetWeightTotal</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">num_times</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">WeightList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_times</span><span class="p">:</span>
                    <span class="n">WL_last</span> <span class="o">=</span> <span class="n">WeightList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">WeightList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">WL_last</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">WeightList</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Need to choose one of the options 1, 2, or 3&quot;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_BandWeightInitialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rbands</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a loop with band data.</span>

<span class="sd">        This initializes the edge weights in `LoopIn` that correspond to a</span>
<span class="sd">        given band (or set of bands) in `rbands`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rbands : list</span>
<span class="sd">            Each element in the list represents a band, and consists of two</span>
<span class="sd">            items: the list of points which define a band (see Loop class</span>
<span class="sd">            documentation), and the weight to add to the loop weightlist.</span>

<span class="sd">        LoopIn : Loop object</span>
<span class="sd">            The weightlist of `LoopIn` will be modified to represent this</span>
<span class="sd">            additional set of bands being added in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">band_data</span> <span class="ow">in</span> <span class="n">rbands</span><span class="p">:</span>
            <span class="n">band</span><span class="p">,</span> <span class="n">wadd</span> <span class="o">=</span> <span class="n">band_data</span>
            <span class="n">numpoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">band</span><span class="p">)</span>
            <span class="n">AreAdjacent</span><span class="p">,</span> <span class="n">CurveLeft</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpoints</span><span class="p">):</span>
                <span class="n">AreAdjacent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ArePointsAdjacent</span><span class="p">(</span><span class="n">band</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">band</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">]))</span>
                <span class="n">triplepts</span> <span class="o">=</span> <span class="p">[</span><span class="n">band</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="n">numpoints</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">],</span>
                             <span class="n">band</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">band</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">]]</span>
                <span class="n">CurveLeft</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_DoesCurveLeft</span><span class="p">(</span><span class="n">triplepts</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpoints</span><span class="p">):</span>
                <span class="n">Bool1</span> <span class="o">=</span> <span class="p">[</span><span class="n">CurveLeft</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">AreAdjacent</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                         <span class="n">CurveLeft</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">]]</span>
                <span class="n">Bool2</span> <span class="o">=</span> <span class="p">[</span><span class="n">AreAdjacent</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="n">numpoints</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">],</span>
                         <span class="n">CurveLeft</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">AreAdjacent</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="n">triplepts</span> <span class="o">=</span> <span class="p">[</span><span class="n">band</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="n">numpoints</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">],</span> <span class="n">band</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                             <span class="n">band</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_AddWeightsAlongLine</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">band</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">band</span><span class="p">[(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">numpoints</span><span class="p">]],</span> <span class="n">Bool1</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">wadd</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_AddWeightsAroundPoint</span><span class="p">(</span><span class="n">triplepts</span><span class="p">,</span> <span class="n">Bool2</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">wadd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ArePointsAdjacent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
        <span class="n">AreAdjacent</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">LRsimps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">LRsimpspos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">simpposcounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">StartSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">pt1</span><span class="p">]</span>
        <span class="n">locid</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pt2</span> <span class="ow">in</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">AreAdjacent</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">LRsimps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">StartSimp</span><span class="p">)</span>
            <span class="n">LRsimpspos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simpposcounter</span><span class="p">)</span>
        <span class="n">simpposcounter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">NextSimp</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">locid</span> <span class="o">=</span> <span class="n">NextSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">NextSimp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">StartSimp</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">LRsimpspos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pt2</span> <span class="ow">in</span> <span class="n">NextSimp</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                <span class="n">AreAdjacent</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">LRsimps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NextSimp</span><span class="p">)</span>
                <span class="n">LRsimpspos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simpposcounter</span><span class="p">)</span>
            <span class="n">simpposcounter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">NextSimp</span> <span class="o">=</span> <span class="n">NextSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">locid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">locid</span> <span class="o">=</span> <span class="n">NextSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">AreAdjacent</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">LRsimpspos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">LRsimpspos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">AreAdjacent</span><span class="p">,</span> <span class="p">[</span><span class="n">LRsimps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">LRsimps</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">AreAdjacent</span><span class="p">,</span> <span class="n">LRsimps</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">AreAdjacent</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_DoesCurveLeft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pttriple</span><span class="p">):</span>
        <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">pt3</span> <span class="o">=</span> <span class="n">pttriple</span>
        <span class="n">pos1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pt1</span><span class="p">]</span>
        <span class="n">pos2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pt2</span><span class="p">]</span>
        <span class="n">pos3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pt3</span><span class="p">]</span>
        <span class="n">crossP</span> <span class="o">=</span> <span class="p">((</span><span class="n">pos3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                  <span class="o">-</span> <span class="p">(</span><span class="n">pos3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">crossP</span> <span class="o">&gt;=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_IsLeft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linepts</span><span class="p">,</span> <span class="n">ptin</span><span class="p">):</span>
        <span class="c1">#  this determines if the given point (ptin) is to the left of line</span>
        <span class="c1">#  that goes from the first to second point in linepts.</span>
        <span class="c1">#  Used in determining the edges crossed in an initial band</span>
        <span class="n">pttriple</span> <span class="o">=</span> <span class="p">[</span><span class="n">ptin</span><span class="p">,</span> <span class="n">linepts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">linepts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DoesCurveLeft</span><span class="p">(</span><span class="n">pttriple</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_AddWeightsAlongLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linepoints</span><span class="p">,</span> <span class="n">Boolin</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">wadd</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="c1">#  This takes the two points in linepoints and adds a weight of one</span>
        <span class="c1">#  (or non-default value) to any edges that are crossed by the line.</span>
        <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span> <span class="o">=</span> <span class="n">linepoints</span>
        <span class="k">if</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1">#  case of adjacent points (i.e. the line between the</span>
            <span class="c1">#  points is an edge). Only if the curvelefts&#39;</span>
            <span class="c1">#  (Boolin[0], Boolin[2]) are opposite one another,</span>
            <span class="c1">#  do we add a weight</span>
            <span class="k">if</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">pt1rtlocid</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
                <span class="n">edgeindex</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">pt1rtlocid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#  determine the direction (which simplex) to set out</span>
            <span class="c1">#  from that has pt1 as a point.</span>
            <span class="n">stlocid</span><span class="p">,</span> <span class="n">StartSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SimpInDir</span><span class="p">([</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">])</span>
            <span class="n">endlocid</span><span class="p">,</span> <span class="n">EndSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SimpInDir</span><span class="p">([</span><span class="n">pt2</span><span class="p">,</span> <span class="n">pt1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">pt2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                <span class="n">edgeindex</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">stlocid</span><span class="p">]</span>
                <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>
                <span class="n">leftpoint</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">stlocid</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">CurrentSimp</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">stlocid</span><span class="p">]</span>
                <span class="n">leftptloc</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">leftpoint</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">CurrentSimp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">EndSimp</span><span class="p">:</span>
                    <span class="n">ptcompare</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">leftptloc</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">indexadd</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsLeft</span><span class="p">(</span><span class="n">linepoints</span><span class="p">,</span> <span class="n">ptcompare</span><span class="p">):</span>
                        <span class="n">indexadd</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">edgeindex</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">leftptloc</span><span class="o">+</span><span class="n">indexadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>
                    <span class="n">leftpoint</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">leftptloc</span><span class="o">+</span><span class="n">indexadd</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">CurrentSimp</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span>
                        <span class="p">(</span><span class="n">leftptloc</span><span class="o">+</span><span class="n">indexadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                    <span class="n">leftptloc</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">leftpoint</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_SimpInDir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linepoints</span><span class="p">):</span>
        <span class="c1">#  this returns the simplex (and local point id) that contains the</span>
        <span class="c1">#  first of linepoints, and has the line (to the second point)</span>
        <span class="c1">#  passing through it</span>
        <span class="n">pt1</span> <span class="o">=</span> <span class="n">linepoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pt2</span> <span class="o">=</span> <span class="n">linepoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">StartSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">pt1</span><span class="p">]</span>
        <span class="n">locpt</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
        <span class="n">ptright</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">ptleft</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locpt</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="p">((</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsLeft</span><span class="p">([</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">],</span> <span class="n">ptright</span><span class="p">))</span>
                   <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IsLeft</span><span class="p">([</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">],</span> <span class="n">ptleft</span><span class="p">)):</span>
            <span class="n">StartSimp</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">locpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">locpt</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span>
            <span class="n">ptright</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locpt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">ptleft</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">locpt</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">locpt</span><span class="p">,</span> <span class="n">StartSimp</span>

    <span class="k">def</span> <span class="nf">_AddWeightsAroundPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pttriple</span><span class="p">,</span> <span class="n">Boolin</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">wadd</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1">#  This takes the central point in pttriple and adds in the weight</span>
        <span class="c1">#  of wadd to each of the radial edges starting from the edge that</span>
        <span class="c1">#  is part of the simplex bisected by pt1 and pt2, to the edge that</span>
        <span class="c1">#  is part of the simplex bisected by pt2 and pt3</span>
        <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">pt3</span> <span class="o">=</span> <span class="n">pttriple</span>
        <span class="n">indadd</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">indadd</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># curve right triggers this</span>
        <span class="n">stlocid</span><span class="p">,</span> <span class="n">StartSimp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">StartSimp</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">StartSimp</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">stlocid</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stlocid</span><span class="p">,</span> <span class="n">StartSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SimpInDir</span><span class="p">([</span><span class="n">pt2</span><span class="p">,</span> <span class="n">pt1</span><span class="p">])</span>
        <span class="n">endlocid</span><span class="p">,</span> <span class="n">EndSimp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">EndSimp</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">EndSimp</span> <span class="o">=</span> <span class="n">Boolin</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">endlocid</span> <span class="o">=</span> <span class="n">EndSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endlocid</span><span class="p">,</span> <span class="n">EndSimp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SimpInDir</span><span class="p">([</span><span class="n">pt2</span><span class="p">,</span> <span class="n">pt3</span><span class="p">])</span>
        <span class="n">edgeindex</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">stlocid</span><span class="o">+</span><span class="n">indadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>
        <span class="n">CurrentSimp</span> <span class="o">=</span> <span class="n">StartSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">stlocid</span><span class="o">+</span><span class="n">indadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">ptloc</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">CurrentSimp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">EndSimp</span><span class="p">:</span>
            <span class="n">edgeindex</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">ptloc</span><span class="o">+</span><span class="n">indadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edgeindex</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>
            <span class="n">CurrentSimp</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[(</span><span class="n">ptloc</span><span class="o">+</span><span class="n">indadd</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">ptloc</span> <span class="o">=</span> <span class="n">CurrentSimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_CurveWeightInitialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curves</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a loop with curve data.</span>

<span class="sd">        This initializes the edge weights in `LoopIn` that correspond to a</span>
<span class="sd">        given set of curves in `curves`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        curves : list</span>
<span class="sd">            Each element in the list represents a curve, and consists of four</span>
<span class="sd">            items: the list of point positions [[x_0,y_0],[x_1,y_1],...],</span>
<span class="sd">            whether the curve is closed (bool), whether the end points are</span>
<span class="sd">            pinned [bool,bool], and finally, the weight to add to the loop</span>
<span class="sd">            weightlist.</span>

<span class="sd">        LoopIn : Loop object</span>
<span class="sd">            The weightlist of LoopIn will be modified to represent this</span>
<span class="sd">            additional set of curves being added in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">:</span>
            <span class="n">point_set</span><span class="p">,</span> <span class="n">is_closed</span><span class="p">,</span> <span class="n">end_pts_pin</span><span class="p">,</span> <span class="n">wadd</span> <span class="o">=</span> <span class="n">curve</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Get_Edges</span><span class="p">(</span><span class="n">point_set</span><span class="p">,</span> <span class="n">is_closed</span><span class="p">,</span> <span class="n">end_pts_pin</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">:</span>
                <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wadd</span>

    <span class="k">def</span> <span class="nf">_Simp_Hop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt_in</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">line_big</span><span class="p">,</span> <span class="n">l_id</span><span class="p">,</span> <span class="n">ix</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">edge_prev</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">next_edge</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#  see if pt_in is in simp.  If not, find edge intersection and then</span>
        <span class="c1">#  get adj simp, find ref point and dx,dy for shift that matches edge</span>
        <span class="c1">#  from simp. Then calls self recursively. Stops when simp is found</span>
        <span class="c1">#  with this point interior.  returns list of pairs [simp, edge]</span>
        <span class="c1">#  along the path line_big</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e-8</span>
        <span class="c1">#  first see if pt_in is in the simp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Tri_Contains</span><span class="p">(</span><span class="n">pt_in</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">l_id</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[[</span><span class="n">simp</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">l_id</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Get_Shifted_Vertices</span><span class="p">(</span><span class="n">simp</span><span class="p">,</span> <span class="n">l_id</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">)</span>
            <span class="n">next_id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">next_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">next_edge</span><span class="p">)</span>
                <span class="n">Line_simp</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">HF</span><span class="o">.</span><span class="n">IsIntersection</span><span class="p">(</span><span class="n">line_big</span><span class="p">,</span> <span class="n">Line_simp</span><span class="p">):</span>
                    <span class="n">next_id</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge_prev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="n">Line_simp</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">HF</span><span class="o">.</span><span class="n">IsIntersection</span><span class="p">(</span><span class="n">line_big</span><span class="p">,</span> <span class="n">Line_simp</span><span class="p">):</span>
                            <span class="n">next_id</span> <span class="o">=</span> <span class="n">i</span>
                            <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">edge_prev</span><span class="p">:</span>
                            <span class="n">Line_simp</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span>
                                         <span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                            <span class="k">if</span> <span class="n">HF</span><span class="o">.</span><span class="n">IsIntersection</span><span class="p">(</span><span class="n">line_big</span><span class="p">,</span> <span class="n">Line_simp</span><span class="p">):</span>
                                <span class="n">next_id</span> <span class="o">=</span> <span class="n">i</span>
                                <span class="k">break</span>
            <span class="k">if</span> <span class="n">next_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span>
            <span class="n">next_simp</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">next_id</span><span class="p">]</span>
            <span class="n">next_edge_id</span> <span class="o">=</span> <span class="n">next_simp</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="c1"># now find the shifted parameters for the next simp</span>
            <span class="c1"># s.t. the geometric edge matches up</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">next_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">next_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">l_id_trial</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">for</span> <span class="n">ix_trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">iy_trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">vertices_trial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Get_Shifted_Vertices</span><span class="p">(</span>
                            <span class="n">next_simp</span><span class="p">,</span> <span class="n">l_id_trial</span><span class="p">,</span> <span class="n">ix_trial</span><span class="p">,</span> <span class="n">iy_trial</span><span class="p">)</span>
                        <span class="n">v1_trial</span> <span class="o">=</span> <span class="n">vertices_trial</span><span class="p">[(</span><span class="n">next_edge_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                        <span class="n">v2_trial</span> <span class="o">=</span> <span class="n">vertices_trial</span><span class="p">[(</span><span class="n">next_edge_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span>
                        <span class="n">diff1</span> <span class="o">=</span> <span class="n">v1_trial</span> <span class="o">-</span> <span class="n">v1</span>
                        <span class="n">diff2</span> <span class="o">=</span> <span class="n">v2_trial</span> <span class="o">-</span> <span class="n">v2</span>
                        <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">diff1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">diff1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">diff2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">diff2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">:</span>
                            <span class="c1"># have a match</span>
                            <span class="k">return</span> <span class="p">([[</span><span class="n">simp</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">l_id</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]]</span>
                                    <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Simp_Hop</span><span class="p">(</span>
                                        <span class="n">pt_in</span><span class="p">,</span> <span class="n">next_simp</span><span class="p">,</span> <span class="n">line_big</span><span class="p">,</span> <span class="n">l_id_trial</span><span class="p">,</span>
                                        <span class="n">ix_trial</span><span class="p">,</span> <span class="n">iy_trial</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_Get_Shifted_Vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">l_id</span><span class="p">,</span> <span class="n">ix</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iy</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">]</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">l_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ix</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">l_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">iy</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">vertices</span><span class="p">[(</span><span class="n">l_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">l_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="n">ix</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vertices</span><span class="p">[(</span><span class="n">l_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">l_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="n">iy</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">vertices</span><span class="p">[(</span><span class="n">l_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">l_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="n">ix</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vertices</span><span class="p">[(</span><span class="n">l_id</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">l_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                                      <span class="o">+</span> <span class="n">iy</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_Tri_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">l_id</span><span class="p">,</span> <span class="n">ix</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iy</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1">#  Determines whether the triangle (simp) contains pt.</span>
        <span class="c1">#  the shifted vertex info is also passed in</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Get_Shifted_Vertices</span><span class="p">(</span><span class="n">simp</span><span class="p">,</span> <span class="n">l_id</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">)</span>
        <span class="n">trial_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">c_i</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">Curl</span><span class="p">(</span><span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                          <span class="n">trial_pt</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">c_i</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_Get_Edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">end_pts_pin</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]):</span>
        <span class="c1">#  Finds the list of edges crossed by the curve represented by</span>
        <span class="c1">#  the list of points (points).</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">nn</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">simp_in</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_Find_Simp</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nn</span><span class="p">))]</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ncl</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">closed</span><span class="p">:</span>
            <span class="n">ncl</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">+</span><span class="n">ncl</span><span class="p">):</span>
            <span class="n">line_big</span> <span class="o">=</span> <span class="p">[</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">points</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)]]</span>
            <span class="n">simp_chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Simp_Hop</span><span class="p">(</span><span class="n">points</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)],</span>
                                        <span class="n">simp_in</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">line_big</span><span class="p">,</span> <span class="n">simp_in</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="n">simp_in</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">simp_in</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">edge_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">simp_chain</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">simp_chain</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">HF</span><span class="o">.</span><span class="n">Reduce_List</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">closed</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">end_pts_pin</span> <span class="o">==</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span>
            <span class="n">temp_edge_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">end_pts_pin</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">st_pt</span> <span class="o">=</span> <span class="n">simp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">temp_edge_list</span> <span class="o">+=</span> <span class="n">simp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">EdgeNeighbors</span><span class="p">(</span>
                    <span class="n">simp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">st_pt</span><span class="p">])</span>
            <span class="n">temp_edge_list</span> <span class="o">+=</span> <span class="n">edge_list</span>
            <span class="k">if</span> <span class="n">end_pts_pin</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">end_pt</span> <span class="o">=</span> <span class="n">simp_in</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">temp_edge_list</span> <span class="o">+=</span> <span class="n">simp_in</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">EdgeNeighbors</span><span class="p">(</span>
                    <span class="n">simp_in</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">end_pt</span><span class="p">])</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="n">temp_edge_list</span> <span class="o">+</span> <span class="n">edge_list</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">edge_list</span>

    <span class="k">def</span> <span class="nf">_Find_Simp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt_in</span><span class="p">,</span> <span class="n">nn_id</span><span class="p">):</span>
        <span class="c1">#  Finds the simplex which contains the input point</span>
        <span class="c1">#  uses the nearest neighbor point (nn_id)</span>
        <span class="n">simp_set</span><span class="p">,</span> <span class="n">l_id_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">nn_id</span><span class="p">]</span><span class="o">.</span><span class="n">SimpNeighbors</span><span class="p">(</span><span class="n">nn_id</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">simp_set</span><span class="p">)):</span>
            <span class="n">simp</span> <span class="o">=</span> <span class="n">simp_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">l_id</span> <span class="o">=</span> <span class="n">l_id_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">l_id</span><span class="p">]</span>
            <span class="n">line_big</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">nn_id</span><span class="p">]),</span> <span class="n">pt_in</span><span class="p">]</span>
            <span class="n">simp_chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Simp_Hop</span><span class="p">(</span><span class="n">pt_in</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">line_big</span><span class="p">,</span> <span class="n">l_id</span><span class="p">,</span>
                                        <span class="n">next_edge</span><span class="o">=</span><span class="n">edge</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">simp_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">simp_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">simp_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">simp_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">simp_chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">4</span><span class="p">]]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_ShearWeightInitialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RegLoop</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a loop a shear coordinate version of another loop.</span>

<span class="sd">        This takes the regular edge weights (for some band) encoded in</span>
<span class="sd">        `RegLoop`, and uses the triangulation connectivity to initialize</span>
<span class="sd">        `LoopIn`, which represents the band in shear coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        RegLoop : Loop object</span>
<span class="sd">            A loop already initialized with regular coordinates.</span>

<span class="sd">        LoopIn : Loop object</span>
<span class="sd">            The loop that will be initialized with shear coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="c1">#  LoopIn must be initialized to all zeros (this catches</span>
                <span class="c1">#  the second time through)</span>
                <span class="k">if</span> <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#  if the value for the regular loop is zero here, then</span>
                    <span class="c1">#  the shear coordinates should be zero</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">RegLoop</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">WA</span> <span class="o">=</span> <span class="n">RegLoop</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                        <span class="n">WB</span> <span class="o">=</span> <span class="n">RegLoop</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                        <span class="n">xsimp</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">Lid</span> <span class="o">=</span> <span class="n">xsimp</span><span class="o">.</span><span class="n">LocalID</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
                        <span class="n">WC</span> <span class="o">=</span> <span class="n">RegLoop</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">xsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">Lid</span><span class="p">]]</span>
                        <span class="n">WD</span> <span class="o">=</span> <span class="n">RegLoop</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">xsimp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[(</span><span class="n">Lid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                        <span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">WA</span><span class="o">+</span><span class="n">WB</span><span class="o">-</span><span class="n">WC</span><span class="o">+</span><span class="n">WD</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>

    <span class="c1"># Plotting</span>
    <span class="k">def</span> <span class="nf">_PlotPrelims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Preliminary setup for plotting.</span>

<span class="sd">        Handles the initial setup for the figure</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        PP : PlotParameters object</span>
<span class="sd">            For this method, the relevant PlotParameters attributes are:</span>

<span class="sd">        Bounds : list of lists</span>
<span class="sd">            Bounds has the format [[x_min, y_min],[x_max, y_max]], and</span>
<span class="sd">            determines the bounding box for plotting. This is usually set</span>
<span class="sd">            automatically.</span>

<span class="sd">        FigureSizeX : float</span>
<span class="sd">            The width of the image in inches.  The height is automatically</span>
<span class="sd">            calculated based on Bounds.</span>

<span class="sd">        dpi : int</span>
<span class="sd">            The dots per inch.  Increase to increase the resolution and size of</span>
<span class="sd">            resulting image file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : matplotlib fig object</span>
<span class="sd">            Not currently used, but might be used in the future to</span>
<span class="sd">            add another subplot</span>

<span class="sd">        ax : matplotlib axis object</span>
<span class="sd">            This is used to add features to the current plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">szx</span> <span class="o">=</span> <span class="n">PP</span><span class="o">.</span><span class="n">FigureSizeX</span>
        <span class="n">szy</span> <span class="o">=</span> <span class="n">szx</span>
        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">szy</span> <span class="o">=</span> <span class="p">(</span><span class="n">szx</span><span class="o">*</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span>
                   <span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">szy</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">PP</span><span class="o">.</span><span class="n">dpi</span><span class="o">*</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">szy</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">dpi</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># szy*dpi must be even</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">szx</span><span class="p">,</span> <span class="n">szy</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">dpi</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;savefig.pad_inches&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">()</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">dpi_scale_trans</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span>
        <span class="n">PP</span><span class="o">.</span><span class="n">_conversion_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">bbox</span><span class="o">.</span><span class="n">width</span><span class="o">/</span><span class="mi">72</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">_TriangulationPlotBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the triangulation.</span>

<span class="sd">        Plots the underlying triangulation</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis object</span>
<span class="sd">            The figure axis to add elements to</span>

<span class="sd">        PP : PlotParameters object</span>
<span class="sd">            For this method, the relevant PlotParameters attributes are:</span>

<span class="sd">        linewidth_tri : float</span>
<span class="sd">            The line width of the background triangulation.</span>

<span class="sd">        linecolor_tri : str</span>
<span class="sd">            The color of the triangulation lines. Default is &#39;g&#39; (green).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">]</span>
        <span class="n">ypoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">]</span>
        <span class="n">trianglesIn</span><span class="p">,</span> <span class="n">EdgeSimp</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">relptregion</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]:</span>
                <span class="n">trianglesIn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">EdgeSimp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1">#  plots the triangles that are completely in the FD</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trianglesIn</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span><span class="n">xpoints</span><span class="p">,</span> <span class="n">ypoints</span><span class="p">,</span> <span class="n">trianglesIn</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">linecolor_tri</span><span class="p">,</span>
                       <span class="n">lw</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tri</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#  plots the triangles that stradle edge(s). This plots mutiple</span>
        <span class="c1">#  copies of each so that the intersection of each with the FD</span>
        <span class="c1">#  is included</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">Simp</span> <span class="ow">in</span> <span class="n">EdgeSimp</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">Simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">nxs</span> <span class="o">=</span> <span class="n">nx</span>
                <span class="k">if</span> <span class="n">nx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nxs</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nxs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
                <span class="n">nys</span> <span class="o">=</span> <span class="n">ny</span>
                <span class="k">if</span> <span class="n">ny</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nys</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nys</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>
                <span class="n">xpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]][</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">ypts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">Simp</span><span class="o">.</span><span class="n">points</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]][</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">nx</span> <span class="o">+</span> <span class="n">nxs</span><span class="p">,</span> <span class="n">nxs</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">ny</span> <span class="o">+</span> <span class="n">nys</span><span class="p">,</span> <span class="n">nys</span><span class="p">):</span>
                        <span class="n">xptsn</span> <span class="o">=</span> <span class="n">xpts</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="n">nx</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">yptsn</span> <span class="o">=</span> <span class="n">ypts</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="n">ny</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">xptsn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">yptsn</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tri</span><span class="p">,</span>
                            <span class="n">colors</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">linecolor_tri</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_PointPlotBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the points.</span>

<span class="sd">        Plots the points</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis object</span>
<span class="sd">            The figure axis to add elements to</span>

<span class="sd">        PP : PlotParameters object</span>
<span class="sd">            For this method, the relevant PlotParameters attributes are:</span>

<span class="sd">        ptlabels : bool</span>
<span class="sd">            If True, the integer label for each point is plotted next to the</span>
<span class="sd">            point. False is default.  Mainly used for visually finding groups</span>
<span class="sd">            of points to encircle with a band.</span>

<span class="sd">        markersize : float</span>
<span class="sd">            Sets the markersize of the points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">]</span>
        <span class="n">ypoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">ptlabels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xpoints</span><span class="p">)):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">xpoints</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">ypoints</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xpoints</span><span class="p">,</span> <span class="n">ypoints</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">markersize</span><span class="p">,</span>
                   <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_TTPlotBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the loop.</span>

<span class="sd">        Plots the train-track representation of the loop</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis object</span>
<span class="sd">            The figure axis to add elements to</span>

<span class="sd">        LoopIn : Loop object</span>
<span class="sd">            The data in LoopIn determine the train-track</span>

<span class="sd">        PP : PlotParameters object</span>
<span class="sd">            For this method, the relevant PlotParameters attributes are:</span>

<span class="sd">        Delaunay : bool</span>
<span class="sd">            Flag - if True then uses Voronoi-based control points to draw the</span>
<span class="sd">            train-track representation of the loops.  If False (default), then</span>
<span class="sd">            triangle centers are used as control points.</span>

<span class="sd">        DelaunayAdd : bool</span>
<span class="sd">            Flag - A different Voronoi-based control point plotting system for</span>
<span class="sd">            the train-tracks.  This represents the train-track weights as line</span>
<span class="sd">            widths, which join naturally at train-track switch locations. This</span>
<span class="sd">            is only relevant if Delaunay is True.</span>

<span class="sd">        color_weights : bool</span>
<span class="sd">            If True, then the individual segments of the train-track will be</span>
<span class="sd">            colored based on their weights.  This is one way to encode weight</span>
<span class="sd">            information in the plots.  Default is False.</span>

<span class="sd">        log_color : bool</span>
<span class="sd">            If True these colors will be assigned using the log of the</span>
<span class="sd">            weights. If False (default), the weights them-selves will</span>
<span class="sd">            determine the color scale.</span>

<span class="sd">        color_map : str</span>
<span class="sd">            The color map to be used, default is &#39;inferno_r&#39;.</span>

<span class="sd">        linewidth_tt : float</span>
<span class="sd">            The line width of the train-track.  If DelaunayAdd is True, then</span>
<span class="sd">            this is the maximum line-width</span>

<span class="sd">        linecolor_tt : str</span>
<span class="sd">            The line color of the train-track. Default is &#39;r&#39; (red).</span>

<span class="sd">        alpha_tt : float</span>
<span class="sd">            The opacity of the train-track.  Default is 1.0 (completely</span>
<span class="sd">            opaque/not transparent).</span>

<span class="sd">        frac : float</span>
<span class="sd">            For plotting with the Delaunay flag, this determined how curved</span>
<span class="sd">            the train-tracks appear.  A value of 1.0 is maximally curvy (no</span>
<span class="sd">            linear segments), while a value of 0.0 would be just straight</span>
<span class="sd">            lines on following the Voronoi skeleton.  Default is 0.9</span>

<span class="sd">        tt_lw_min_frac : float</span>
<span class="sd">            The minimum fraction of linewidth_tt that will be represented.</span>
<span class="sd">            This means that all train-track segments with weights below this</span>
<span class="sd">            fraction of the maximum weight will be represented as this</span>
<span class="sd">            fraction of linewidth_tt.  All segments with larger weight will</span>
<span class="sd">            have a line width that linear in this range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  keeps track of segments that have been plotted</span>
        <span class="c1">#  (so as to not plot an element twice)</span>
        <span class="n">EdgePlotted</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span><span class="p">)]</span>
        <span class="n">ttpatches</span><span class="p">,</span> <span class="n">cweights</span><span class="p">,</span> <span class="n">line_widths</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">Delaunay</span><span class="p">:</span>  <span class="c1"># regular case, works for any triangulation</span>
            <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
                <span class="n">new_ttpatches</span><span class="p">,</span> <span class="n">new_cweights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GeneralSimplexTTPlot</span><span class="p">(</span>
                    <span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">EdgePlotted</span><span class="p">,</span> <span class="n">PP</span><span class="p">)</span>
                <span class="n">ttpatches</span> <span class="o">+=</span> <span class="n">new_ttpatches</span>
                <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                    <span class="n">cweights</span> <span class="o">+=</span> <span class="n">new_cweights</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># looks nicer, but only works for a Delaunay triangulation</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">DelaunayAdd</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
                    <span class="n">new_ttpatches</span><span class="p">,</span> <span class="n">new_cweights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DelaunaySimplexTTPlot</span><span class="p">(</span>
                        <span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">EdgePlotted</span><span class="p">,</span> <span class="n">PP</span><span class="p">)</span>
                    <span class="n">ttpatches</span> <span class="o">+=</span> <span class="n">new_ttpatches</span>
                    <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                        <span class="n">cweights</span> <span class="o">+=</span> <span class="n">new_cweights</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">PP</span><span class="o">.</span><span class="n">_max_weight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">simp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">:</span>
                    <span class="n">new_ttpatches</span><span class="p">,</span> <span class="n">new_cweights</span><span class="p">,</span> <span class="n">new_l_widths</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_DelaunaySimplexTTPlot_exp</span><span class="p">(</span><span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">PP</span><span class="p">))</span>
                    <span class="n">ttpatches</span> <span class="o">+=</span> <span class="n">new_ttpatches</span>
                    <span class="n">line_widths</span> <span class="o">+=</span> <span class="n">new_l_widths</span>
                    <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                        <span class="n">cweights</span> <span class="o">+=</span> <span class="n">new_cweights</span>
        <span class="n">Pcollection</span> <span class="o">=</span> <span class="n">PatchCollection</span><span class="p">(</span><span class="n">ttpatches</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">alpha_tt</span><span class="p">,</span>
                                      <span class="n">capstyle</span><span class="o">=</span><span class="s1">&#39;butt&#39;</span><span class="p">,</span> <span class="n">joinstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span>
                                      <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">DelaunayAdd</span><span class="p">:</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">line_widths</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linecolor_tt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">log_color</span><span class="p">:</span>
                <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">cweights</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">cweights</span><span class="p">)</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">color_map</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">Pcollection</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_GeneralSimplexTTPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">EdgePlotted</span><span class="p">,</span> <span class="n">PP</span><span class="p">):</span>
        <span class="c1">#  plot the segments of train tracks</span>
        <span class="c1">#  that are determined from a given simplex</span>
        <span class="n">patches_out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights_out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">]</span>  <span class="c1"># edge weights</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="n">srpr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">)</span>
        <span class="n">FDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>  <span class="c1"># if there are any weights to plot</span>
            <span class="c1"># locations of the three simplex vertices</span>
            <span class="n">vertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pts</span><span class="p">]</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">])</span>
            <span class="c1"># local id of the extra point in each of the 3</span>
            <span class="c1"># surrounding simplices</span>
            <span class="n">exlids</span> <span class="o">=</span> <span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1"># locations of the extra point in each of the 3</span>
            <span class="c1"># surrounding simplices</span>
            <span class="n">exvertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">exlids</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1"># convention - first point in simp.points will be treated as being</span>
            <span class="c1"># in the FD</span>
            <span class="c1"># now let&#39;s modify the positions of all the other points</span>
            <span class="n">vertpts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">srpr</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">srpr</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">vertpts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">srpr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">exlids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">exlids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">exlids</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># now let&#39;s get the simplex geometric centers and edge</span>
            <span class="c1"># halfwaypoints</span>
            <span class="n">SimpCenter</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">(</span><span class="n">vertpts</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">AdjSimpCenters</span> <span class="o">=</span> <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vertpts</span><span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">exvertpts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                 <span class="n">vertpts</span><span class="p">[(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="n">EdgeHalf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vertpts</span><span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">vertpts</span><span class="p">[(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1"># now the points that are halfway between the edge centers</span>
            <span class="c1"># and the simpcenter</span>
            <span class="n">CenterEdgeHalf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">([</span><span class="n">SimpCenter</span><span class="p">,</span> <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1"># now the points that are halfway between the edge centers</span>
            <span class="c1"># and the adjacent simplex centers</span>
            <span class="n">AdjEdgeHalf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">AdjSimpCenters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1"># check that the quadratic Bezier control triangle doesn&#39;t contain</span>
            <span class="c1"># a vertex.  If so, we modify the control points</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">side</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># default is left</span>
                <span class="n">C1</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">Curl</span><span class="p">(</span><span class="n">AdjEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                             <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">CenterEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                <span class="k">if</span> <span class="n">C1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">side</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># right</span>
                <span class="n">Line1</span> <span class="o">=</span> <span class="p">[</span><span class="n">CenterEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">AdjEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]]</span>
                <span class="n">Line2</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertpts</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">side</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]]</span>
                <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetIntersectionTimes</span><span class="p">(</span><span class="n">Line1</span><span class="p">,</span> <span class="n">Line2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">t2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># need to modify</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="o">-</span><span class="n">t2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t2</span><span class="p">)</span>
                    <span class="n">CenterEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">CenterEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                                            <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">AdjEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">AdjEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                                         <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
            <span class="c1"># the interior weights</span>
            <span class="n">Wp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]:</span>
                <span class="c1"># only need to print once</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">EdgePlotted</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                        <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                            <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HF</span><span class="o">.</span><span class="n">BezierQuad</span><span class="p">(</span>
                                <span class="n">CenterEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">EdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                                <span class="n">AdjEdgeHalf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
                            <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                                <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">EdgePlotted</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                        <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HF</span><span class="o">.</span><span class="n">BezierQuad</span><span class="p">(</span>
                            <span class="n">CenterEdgeHalf</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">SimpCenter</span><span class="p">,</span>
                            <span class="n">CenterEdgeHalf</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]))</span>
                        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                            <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># the simplex straddles edges</span>
                <span class="n">ptregionx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                             <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">ptregiony</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                             <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">xint</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">ptregionx</span><span class="p">),</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">ptregionx</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">yint</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">ptregiony</span><span class="p">),</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">ptregiony</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xint</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yint</span><span class="p">])</span>
                        <span class="c1"># shift all the control points and plot again</span>
                        <span class="n">SC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SimpCenter</span><span class="p">)</span> <span class="o">+</span> <span class="n">dr</span>
                        <span class="n">CEH</span> <span class="o">=</span> <span class="n">CenterEdgeHalf</span> <span class="o">+</span> <span class="n">dr</span>
                        <span class="n">AEH</span> <span class="o">=</span> <span class="n">AdjEdgeHalf</span> <span class="o">+</span> <span class="n">dr</span>
                        <span class="n">EH</span> <span class="o">=</span> <span class="n">EdgeHalf</span> <span class="o">+</span> <span class="n">dr</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">EdgePlotted</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="ow">and</span>
                                    <span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">)):</span>
                                <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HF</span><span class="o">.</span><span class="n">BezierQuad</span><span class="p">(</span>
                                    <span class="n">CEH</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">EH</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">AEH</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
                                <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                                    <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                                <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HF</span><span class="o">.</span><span class="n">BezierQuad</span><span class="p">(</span>
                                    <span class="n">CEH</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">SC</span><span class="p">,</span> <span class="n">CEH</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]))</span>
                                <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                                    <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">EdgePlotted</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">patches_out</span><span class="p">,</span> <span class="n">weights_out</span>

    <span class="k">def</span> <span class="nf">_DelaunaySimplexTTPlot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">EdgePlotted</span><span class="p">,</span> <span class="n">PP</span><span class="p">):</span>
        <span class="c1">#  used in other function to plot the segments of train tracks that</span>
        <span class="c1">#  are determined from a given simplex this version assumes the</span>
        <span class="c1">#  triangulation is Delaunay, and uses the dual Voroni Centers as</span>
        <span class="c1">#  control points</span>
        <span class="n">patches_out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights_out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">]</span>  <span class="c1"># edge weights</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="n">srpr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">)</span>
        <span class="n">FDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>  <span class="c1"># if there are any weights to plot</span>
            <span class="c1"># locations of the three simplex vertices</span>
            <span class="n">vertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pts</span><span class="p">]</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">])</span>
            <span class="c1"># local id of the extra point in each of the 3</span>
            <span class="c1"># surrounding simplices</span>
            <span class="n">exlids</span> <span class="o">=</span> <span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1"># locations of the extra point in each of the 3</span>
            <span class="c1"># surrounding simplices</span>
            <span class="n">exvertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">exlids</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1"># convention - first point in simp.points will be treated as being</span>
            <span class="c1"># in the FD</span>
            <span class="c1"># now let&#39;s modify the positions of all the other points</span>
            <span class="n">vertpts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">srpr</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">srpr</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">vertpts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">srpr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">exlids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">exlids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">exlids</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># now let&#39;s get the simplex Voronoi centers and halfwaypoints</span>
            <span class="n">SimpVCenter</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetCircumCircleCenter</span><span class="p">(</span><span class="n">vertpts</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">AdjSimpVCenters</span> <span class="o">=</span> <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCircumCircleCenter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vertpts</span><span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">exvertpts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                 <span class="n">vertpts</span><span class="p">[(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1"># halfway between Voronoi centers</span>
            <span class="n">HalfVCs</span> <span class="o">=</span> <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">SimpVCenter</span><span class="p">,</span> <span class="n">AdjSimpVCenters</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1"># now the points that partway (frac) from Center</span>
            <span class="c1"># voroni to HalfVCs</span>
            <span class="n">FracControlPts_In</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">LinFuncInterp</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">,</span> <span class="n">HalfVCs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">frac</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">FracControlPts_Out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">LinFuncInterp</span><span class="p">(</span><span class="n">AdjSimpVCenters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">HalfVCs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">frac</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1"># the interior weights</span>
            <span class="n">Wp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="n">Vpts_copy_loc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">HalfVCs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">HalfVCs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">Vpts_copy_loc</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># only need to print once (but check for Voronoi center out</span>
                <span class="c1"># of FD)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">EdgePlotted</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                        <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                            <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HF</span><span class="o">.</span><span class="n">BezierLinear</span><span class="p">(</span>
                                <span class="n">FracControlPts_In</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                                <span class="n">FracControlPts_Out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
                            <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                                <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">EdgePlotted</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                        <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HF</span><span class="o">.</span><span class="n">BezierQuad</span><span class="p">(</span>
                            <span class="n">FracControlPts_In</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">SimpVCenter</span><span class="p">,</span>
                            <span class="n">FracControlPts_In</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]))</span>
                        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                            <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the simplex straddles edges or the voronoi center</span>
                <span class="c1"># is out of the FD</span>
                <span class="n">xstart</span><span class="p">,</span> <span class="n">xstop</span><span class="p">,</span> <span class="n">ystart</span><span class="p">,</span> <span class="n">ystop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">xstart</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">xstop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">ystart</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">ystop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ptregionx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="o">-</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">ptregiony</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="o">-</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">xstart</span> <span class="o">=</span> <span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">ptregionx</span><span class="p">)</span>
                    <span class="n">xstop</span> <span class="o">=</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">ptregionx</span><span class="p">)</span>
                    <span class="n">ystart</span> <span class="o">=</span> <span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">ptregiony</span><span class="p">)</span>
                    <span class="n">ystop</span> <span class="o">=</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">ptregiony</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">xint</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xstart</span><span class="p">,</span> <span class="n">xstop</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">yint</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ystart</span><span class="p">,</span> <span class="n">ystop</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xint</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yint</span><span class="p">])</span>
                        <span class="c1"># shift all the control points and plot again</span>
                        <span class="n">SC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">)</span> <span class="o">+</span> <span class="n">dr</span>
                        <span class="n">FCPI</span> <span class="o">=</span> <span class="n">FracControlPts_In</span> <span class="o">+</span> <span class="n">dr</span>
                        <span class="n">FCPO</span> <span class="o">=</span> <span class="n">FracControlPts_Out</span> <span class="o">+</span> <span class="n">dr</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                                <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="n">HF</span><span class="o">.</span><span class="n">BezierLinear</span><span class="p">(</span><span class="n">FCPI</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">FCPO</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
                                <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                                    <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                                <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="n">HF</span><span class="o">.</span><span class="n">BezierQuad</span><span class="p">(</span><span class="n">FCPI</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">SC</span><span class="p">,</span>
                                                  <span class="n">FCPI</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]))</span>
                                <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                                    <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">patches_out</span><span class="p">,</span> <span class="n">weights_out</span>

    <span class="k">def</span> <span class="nf">_DelaunaySimplexTTPlot_exp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simp</span><span class="p">,</span> <span class="n">LoopIn</span><span class="p">,</span> <span class="n">PP</span><span class="p">):</span>
        <span class="c1">#  used in other function to plot the segments of train tracks that</span>
        <span class="c1">#  are determined from a given simplex this version assumes the</span>
        <span class="c1">#  triangulation is Delaunay, and uses the dual Voroni Centers as</span>
        <span class="c1">#  control points this is an experimental version, where I work on</span>
        <span class="c1">#  ideas before incorporating them into the main plotting</span>
        <span class="n">patches_out</span><span class="p">,</span> <span class="n">weights_out</span><span class="p">,</span> <span class="n">line_weights_out</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="n">LoopIn</span><span class="o">.</span><span class="n">weightlist</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">]</span>  <span class="c1"># edge weights</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="n">srpr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">)</span>
        <span class="n">FDs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>  <span class="c1"># if there are any weights to plot</span>
            <span class="c1"># locations of the three simplex vertices</span>
            <span class="n">vertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">pts</span><span class="p">]</span> <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">simp</span><span class="o">.</span><span class="n">points</span><span class="p">])</span>
            <span class="c1"># local id of the extra point in each of the 3 surrounding</span>
            <span class="c1"># simplices</span>
            <span class="n">exlids</span> <span class="o">=</span> <span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">edgeids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="c1"># locations of the extra point in each of the 3</span>
            <span class="c1"># surrounding simplices</span>
            <span class="n">exvertpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">[</span><span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">exlids</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="c1"># convention - first point in simp.points will be treated as being</span>
            <span class="c1"># in the FD</span>
            <span class="c1"># now let&#39;s modify the positions of all the other points</span>
            <span class="n">vertpts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">srpr</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">srpr</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">vertpts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">srpr</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">exlids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">exlids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">exvertpts</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">FDs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">simp</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[(</span><span class="n">exlids</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># now let&#39;s get the simplex Voronoi centers and halfwaypoints</span>
            <span class="n">SimpVCenter</span> <span class="o">=</span> <span class="n">HF</span><span class="o">.</span><span class="n">GetCircumCircleCenter</span><span class="p">(</span><span class="n">vertpts</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">AdjSimpVCenters</span> <span class="o">=</span> <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCircumCircleCenter</span><span class="p">(</span>
                <span class="p">[</span><span class="n">vertpts</span><span class="p">[(</span><span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span> <span class="n">exvertpts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span>
                 <span class="n">vertpts</span><span class="p">[(</span><span class="mi">2</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="n">HalfVCs</span> <span class="o">=</span> <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">GetCenter</span><span class="p">([</span><span class="n">SimpVCenter</span><span class="p">,</span> <span class="n">AdjSimpVCenters</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>  <span class="c1"># halfway between Voronoi centers</span>
            <span class="c1"># now the points that partway (frac) from Center voroni to HalfVCs</span>
            <span class="n">FracControlPts_In</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">HF</span><span class="o">.</span><span class="n">LinFuncInterp</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">,</span> <span class="n">HalfVCs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">PP</span><span class="o">.</span><span class="n">frac</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">Wp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">W</span><span class="p">[(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">W</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>  <span class="c1"># the interior weights</span>
            <span class="n">W_scaled</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">Wp_scaled</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">PP</span><span class="o">.</span><span class="n">_max_weight</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">tt_lw_min_frac</span><span class="p">:</span>
                    <span class="n">W_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tt</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">tt_lw_min_frac</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">W_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tt</span><span class="o">*</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">PP</span><span class="o">.</span><span class="n">_max_weight</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">PP</span><span class="o">.</span><span class="n">_max_weight</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">tt_lw_min_frac</span><span class="p">:</span>
                    <span class="n">Wp_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tt</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">tt_lw_min_frac</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Wp_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_tt</span><span class="o">*</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">PP</span><span class="o">.</span><span class="n">_max_weight</span><span class="p">))</span>
            <span class="c1"># now find the modified control points</span>
            <span class="n">rmp90</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">rmm90</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">FCP_m_center</span> <span class="o">=</span> <span class="n">FracControlPts_In</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">)</span>
            <span class="n">FCP_m_center_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">FCP_m_center</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">FCP_m_center</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">displace_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">W_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Wp_scaled</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">_conversion_factor</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">displace_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[(</span><span class="n">W_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Wp_scaled</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">PP</span><span class="o">.</span><span class="n">_conversion_factor</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">FCP_m_center_rotp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rmp90</span><span class="p">,</span> <span class="n">FCP_m_center</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">FCP_m_center_rotm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rmm90</span><span class="p">,</span> <span class="n">FCP_m_center</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">scaling_l</span> <span class="o">=</span> <span class="n">displace_l</span><span class="o">/</span><span class="n">FCP_m_center_mag</span>
            <span class="n">scaling_r</span> <span class="o">=</span> <span class="n">displace_r</span><span class="o">/</span><span class="n">FCP_m_center_mag</span>
            <span class="n">delta_vec_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">FCP_m_center_rotp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">scaling_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">delta_vec_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">FCP_m_center_rotm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">scaling_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">FCP_mod_l</span> <span class="o">=</span> <span class="n">delta_vec_l</span> <span class="o">+</span> <span class="n">FracControlPts_In</span>
            <span class="n">FCP_mod_r</span> <span class="o">=</span> <span class="n">delta_vec_r</span> <span class="o">+</span> <span class="n">FracControlPts_In</span>
            <span class="n">Center_mod_l</span> <span class="o">=</span> <span class="n">delta_vec_l</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">)</span>
            <span class="n">Center_mod_r</span> <span class="o">=</span> <span class="n">delta_vec_r</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">)</span>
            <span class="n">HalfVCs_mod_l</span> <span class="o">=</span> <span class="n">delta_vec_l</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">HalfVCs</span><span class="p">)</span>
            <span class="n">HalfVCs_mod_r</span> <span class="o">=</span> <span class="n">delta_vec_r</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">HalfVCs</span><span class="p">)</span>
            <span class="n">center_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">HF</span><span class="o">.</span><span class="n">GetIntersectionPoint</span><span class="p">(</span>
                <span class="p">[</span><span class="n">FCP_mod_r</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">Center_mod_r</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]],</span>
                <span class="p">[</span><span class="n">FCP_mod_l</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">Center_mod_l</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">control_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">HalfVCs_mod_r</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">FCP_mod_r</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">center_m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                  <span class="n">FCP_mod_l</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="n">HalfVCs_mod_l</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]]</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
            <span class="n">Vpts_copy_loc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span>
                <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">SimpVCenter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">HalfVCs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">HalfVCs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">Vpts_copy_loc</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># only need to print once (but check for Voronoi center</span>
                <span class="c1"># out of FD)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                        <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HF</span><span class="o">.</span><span class="n">BezierCustom</span><span class="p">(</span>
                            <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                            <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:],</span>
                            <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">:]))</span>
                        <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                            <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">line_weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the simplex straddles edges or the voronoi center is out</span>
                <span class="c1"># of the FD</span>
                <span class="n">xstart</span><span class="p">,</span> <span class="n">xstop</span><span class="p">,</span> <span class="n">ystart</span><span class="p">,</span> <span class="n">ystop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]:</span>
                    <span class="n">xstart</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">xstop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">ystart</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">ystop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">Vpts_copy_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ptregionx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="o">-</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">ptregiony</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="o">-</span><span class="n">simp</span><span class="o">.</span><span class="n">relptregion</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">xstart</span> <span class="o">=</span> <span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">ptregionx</span><span class="p">)</span>
                    <span class="n">xstop</span> <span class="o">=</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">ptregionx</span><span class="p">)</span>
                    <span class="n">ystart</span> <span class="o">=</span> <span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">ptregiony</span><span class="p">)</span>
                    <span class="n">ystop</span> <span class="o">=</span> <span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">ptregiony</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">xint</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xstart</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">xstop</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">yint</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ystart</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ystop</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                        <span class="n">dr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xint</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">yint</span><span class="p">])</span>
                        <span class="c1"># shift all the control points and plot again</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">:</span>
                                <span class="n">patches_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">HF</span><span class="o">.</span><span class="n">BezierCustom</span><span class="p">(</span>
                                    <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span>
                                    <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span>
                                    <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span>
                                    <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span>
                                    <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">dr</span><span class="p">))</span>
                                <span class="k">if</span> <span class="n">PP</span><span class="o">.</span><span class="n">color_weights</span><span class="p">:</span>
                                    <span class="n">weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                <span class="n">line_weights_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Wp_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">patches_out</span><span class="p">,</span> <span class="n">weights_out</span><span class="p">,</span> <span class="n">line_weights_out</span>

    <span class="k">def</span> <span class="nf">_GeoPlotBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">GCurvesIn</span><span class="p">,</span> <span class="n">PP</span><span class="p">:</span> <span class="n">PlotParameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot the geometric curve.</span>

<span class="sd">        Plots the given geometric curve</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib axis object</span>
<span class="sd">            The figure axis to add elements to</span>

<span class="sd">        GCurvesIn : List of curves</span>
<span class="sd">            List of Geometric Curves; data for each curve is same as used in</span>
<span class="sd">            loop initialization from curve:</span>
<span class="sd">            point_set, is_closed, end_pts_pin, wadd = curve</span>
<span class="sd">            end_pts_pin and wadd are ignored</span>

<span class="sd">        PP : PlotParameters object</span>
<span class="sd">            For this method, the relevant PlotParameters attributes are:</span>

<span class="sd">        linewidth_curve : float</span>
<span class="sd">            The line width of the geometric curve. Default is 1.0</span>

<span class="sd">        linecolor_curve : str</span>
<span class="sd">            The line color of the geometric curve. Default is &#39;b&#39; (blue).</span>

<span class="sd">        alpha_curve : float</span>
<span class="sd">            The opacity of the geometric curve.  Default is 1.0 (completely</span>
<span class="sd">            opaque/not transparent).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">GCurvesIn</span><span class="p">:</span>
            <span class="n">point_set</span><span class="p">,</span> <span class="n">is_closed</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">curve</span>
            <span class="n">gcpatches</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">is_closed</span><span class="p">:</span>
                <span class="n">wrap</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">point_set</span><span class="p">)</span><span class="o">+</span><span class="n">wrap</span><span class="p">):</span>
                <span class="n">gcpatches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">HF</span><span class="o">.</span><span class="n">BezierLinear</span><span class="p">(</span><span class="n">point_set</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                    <span class="n">point_set</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_set</span><span class="p">)]))</span>
            <span class="n">Pcollection</span> <span class="o">=</span> <span class="n">PatchCollection</span><span class="p">(</span><span class="n">gcpatches</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
                                          <span class="n">alpha</span><span class="o">=</span><span class="n">PP</span><span class="o">.</span><span class="n">alpha_curve</span><span class="p">,</span>
                                          <span class="n">capstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span>
                                          <span class="n">joinstyle</span><span class="o">=</span><span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_linewidth</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linewidth_curve</span><span class="p">)</span>
            <span class="n">Pcollection</span><span class="o">.</span><span class="n">set_edgecolor</span><span class="p">(</span><span class="n">PP</span><span class="o">.</span><span class="n">linecolor_curve</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">Pcollection</span><span class="p">)</span>

<div class="viewcode-block" id="Triangulation2D.TriCopy">
<a class="viewcode-back" href="../top_advec_pbc.html#top_advec_pbc.Triangulation2D.TriCopy">[docs]</a>
    <span class="k">def</span> <span class="nf">TriCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">EvolutionReset</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a copy of this Triangulation2D object.</span>

<span class="sd">        Custom, as a deepcopy is not sufficient.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        EvolutionReset : bool</span>
<span class="sd">            If True (default), then the WeightOperatorList is reset to</span>
<span class="sd">            be an empty list.  i.e. the memory of any past evolution</span>
<span class="sd">            is ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Triangulation2D object</span>
<span class="sd">            Returns a copy of this Triangulation2D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  create an empty triangulation object (to be returned at the end)</span>
        <span class="n">TriC</span> <span class="o">=</span> <span class="n">Triangulation2D</span><span class="p">([],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">EvolutionReset</span><span class="p">:</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">_atstep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atstep</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">FDsizes</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FDsizes</span><span class="p">)</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">_ptnum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ptnum</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">pointpos</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointpos</span><span class="p">)</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">_pointposfuture</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointposfuture</span><span class="p">)</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">_totalnumedges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_totalnumedges</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">_Vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Vec</span>
        <span class="c1"># create the simplist</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">)):</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Simplex2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">edgeids</span><span class="p">)</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">SLindex</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">relptregion</span><span class="p">)</span>
        <span class="c1"># now create the links</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">SLindex</span><span class="p">]</span>
        <span class="c1"># now fill the pointlist</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">pointlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">)):</span>
            <span class="n">TriC</span><span class="o">.</span><span class="n">pointlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TriC</span><span class="o">.</span><span class="n">simplist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pointlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">SLindex</span><span class="p">])</span>
        <span class="c1"># if we do not reset the evolution related items, we copy them</span>
        <span class="n">TriC</span><span class="o">.</span><span class="n">WeightOperatorList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">EvolutionReset</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">)):</span>
                <span class="n">TriC</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">WeightOperator</span><span class="p">(</span>
                    <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">es</span><span class="p">)))</span>
                <span class="n">TriC</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">WeightOperatorList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TriC</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Spencer A. Smith.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>